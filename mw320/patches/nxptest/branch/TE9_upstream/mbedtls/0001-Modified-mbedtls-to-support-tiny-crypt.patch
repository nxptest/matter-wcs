From 66562ab1b5280bd21576c770230b949cba1088ed Mon Sep 17 00:00:00 2001
From: David Lin <yu-hao.lin@nxp.com>
Date: Thu, 9 Jun 2022 16:17:43 +0800
Subject: [PATCH] Modified mbedtls to support tiny crypt.

Signed-off-by: David Lin <yu-hao.lin@nxp.com>
---
 include/mbedtls/check_config.h  |   18 +-
 include/mbedtls/config.h        |   41 +
 include/mbedtls/oid.h           |   13 +
 include/mbedtls/pk.h            |   21 +
 include/mbedtls/pk_internal.h   |  128 +++
 include/mbedtls/platform.h      |    4 +
 include/mbedtls/platform_util.h |  174 +++
 include/tinycrypt/ecc.h         |  479 ++++++++
 include/tinycrypt/ecc_dh.h      |  134 +++
 include/tinycrypt/ecc_dsa.h     |  142 +++
 library/oid.c                   |   31 +-
 library/pk.c                    |  319 +++++-
 library/pkparse.c               |  238 +++-
 library/pkwrite.c               |  107 +-
 library/platform_util.c         |  334 ++++++
 library/x509_crt.c              |   18 +-
 tinycrypt/CMakeLists.txt        |    7 +
 tinycrypt/LICENSE               |   61 +
 tinycrypt/README                |   77 ++
 tinycrypt/ecc.c                 | 1875 +++++++++++++++++++++++++++++++
 tinycrypt/ecc_dh.c              |  199 ++++
 tinycrypt/ecc_dsa.c             |  318 ++++++
 22 files changed, 4715 insertions(+), 23 deletions(-)
 create mode 100755 include/tinycrypt/ecc.h
 create mode 100755 include/tinycrypt/ecc_dh.h
 create mode 100755 include/tinycrypt/ecc_dsa.h
 create mode 100755 tinycrypt/CMakeLists.txt
 create mode 100755 tinycrypt/LICENSE
 create mode 100755 tinycrypt/README
 create mode 100755 tinycrypt/ecc.c
 create mode 100755 tinycrypt/ecc_dh.c
 create mode 100755 tinycrypt/ecc_dsa.c

diff --git a/include/mbedtls/check_config.h b/include/mbedtls/check_config.h
index 1ebb7066a..b5d4663ba 100644
--- a/include/mbedtls/check_config.h
+++ b/include/mbedtls/check_config.h
@@ -90,6 +90,18 @@
 #error "MBEDTLS_CMAC_C defined, but not all prerequisites"
 #endif
 
+#if defined(MBEDTLS_USE_TINYCRYPT) && defined(MBEDTLS_NO_64BIT_MULTIPLICATION)
+#error "MBEDTLS_USE_TINYCRYPT defined, but it cannot be defined with MBEDTLS_NO_64BIT_MULTIPLICATION"
+#endif
+#if defined(MBEDTLS_USE_TINYCRYPT) && !defined(MBEDTLS_SHA256_C)
+#error "MBEDTLS_USE_TINYCRYPT defined, but not MBEDTLS_SHA256_C"
+#endif
+#if defined(MBEDTLS_OPTIMIZE_TINYCRYPT_ASM) &&           \
+    ( !defined(MBEDTLS_HAVE_ASM) || \
+      !defined(MBEDTLS_USE_TINYCRYPT) )
+#error "MBEDTLS_OPTIMIZE_TINYCRYPT_ASM defined, but not all prerequesites"
+#endif
+
 #if defined(MBEDTLS_NIST_KW_C) && \
     ( !defined(MBEDTLS_AES_C) || !defined(MBEDTLS_CIPHER_C) )
 #error "MBEDTLS_NIST_KW_C defined, but not all prerequisites"
@@ -354,8 +366,10 @@
 #error "MBEDTLS_PEM_WRITE_C defined, but not all prerequisites"
 #endif
 
-#if defined(MBEDTLS_PK_C) && \
-    ( !defined(MBEDTLS_RSA_C) && !defined(MBEDTLS_ECP_C) )
+#if defined(MBEDTLS_PK_C) &&                    \
+    ( !defined(MBEDTLS_RSA_C) &&                \
+      !defined(MBEDTLS_ECP_C) &&                \
+      !defined(MBEDTLS_USE_TINYCRYPT) )
 #error "MBEDTLS_PK_C defined, but not all prerequisites"
 #endif
 
diff --git a/include/mbedtls/config.h b/include/mbedtls/config.h
index 464b61ee2..d75287aab 100644
--- a/include/mbedtls/config.h
+++ b/include/mbedtls/config.h
@@ -2703,6 +2703,47 @@
  */
 #define MBEDTLS_ECP_C
 
+/**
+ * \def MBEDTLS_USE_TINYCRYPT
+ *
+ * Enable the TinyCrypt ECC library. This module provides alternative ECC
+ * handling functions replacing the native Mbed TLS ECP module.
+ *
+ * TinyCrypt is a project independent from Mbed TLS, licensed under 3-clause
+ * BSD, and can be found at https://github.com/intel/tinycrypt - this option
+ * only enables the ECC modules from TinyCrypt.
+ *
+ * Requires: MBEDTLS_SSL_CONF_RNG			(can be ignored for the moment since we don't use ssl)		
+ *           MBEDTLS_SSL_CONF_SINGLE_EC		(can be ignored for the moment since we don't use ssl)		
+ *           MBEDTLS_SSL_CONF_SINGLE_EC_TLS_ID == 23	(can be ignored for the moment since we don't use ssl)		
+ *           MBEDTLS_SSL_CONF_SINGLE_UECC_GRP_ID == MBEDTLS_UECC_DP_SECP256R1	(can be ignored for the moment since we don't use ssl)		
+ *           MBEDTLS_SHA256_C
+ *
+ * \see MBEDTLS_SSL_CONF_RNG
+ *
+ * \see MBEDTLS_SSL_CONF_SINGLE_EC
+ *
+ * Module:  tinycrypt/ecc.c
+ *          tinycrypt/ecc_dh.c
+ *          tinycrypt/ecc_dsa.c
+ */
+#define MBEDTLS_USE_TINYCRYPT
+
+/**
+ * \def MBEDTLS_OPTIMIZE_TINYCRYPT_ASM
+ *
+ * Optimize TinyCrypt operations using assembly.
+ * Add T32/A32 assembly for core tinycrypt/microecc routines, for ARMC5 and GCC;
+ * Use fast integer types to avoid frequent narrowing instructions;
+ * Use __builtin_clz and avoid boolean ops.
+ *
+ * Requires: MBEDTLS_USE_TINYCRYPT
+ *           MBEDTLS_HAVE_ASM
+ *
+ * Module:  tinycrypt/ecc.c
+ */
+#define MBEDTLS_OPTIMIZE_TINYCRYPT_ASM
+
 /**
  * \def MBEDTLS_ENTROPY_C
  *
diff --git a/include/mbedtls/oid.h b/include/mbedtls/oid.h
index e4c697b2d..6dea3b157 100644
--- a/include/mbedtls/oid.h
+++ b/include/mbedtls/oid.h
@@ -501,6 +501,18 @@ int mbedtls_oid_get_pk_alg( const mbedtls_asn1_buf *oid, mbedtls_pk_type_t *pk_a
 int mbedtls_oid_get_oid_by_pk_alg( mbedtls_pk_type_t pk_alg,
                            const char **oid, size_t *olen );
 
+#if defined(MBEDTLS_USE_TINYCRYPT)
+typedef enum
+{
+    MBEDTLS_UECC_DP_NONE = 0,       /*!< Curve not defined. */
+    MBEDTLS_UECC_DP_SECP256R1,      /*!< Domain parameters for the 256-bit curve defined by FIPS 186-4 and SEC1. */
+} mbedtls_uecc_group_id;
+
+int mbedtls_oid_get_ec_grp( const mbedtls_asn1_buf *oid, mbedtls_uecc_group_id *grp_id );
+
+int mbedtls_oid_get_oid_by_ec_grp( mbedtls_uecc_group_id grp_id,
+                            const char **oid, size_t *olen);
+#else
 #if defined(MBEDTLS_ECP_C)
 /**
  * \brief          Translate NamedCurve OID into an EC group identifier
@@ -524,6 +536,7 @@ int mbedtls_oid_get_ec_grp( const mbedtls_asn1_buf *oid, mbedtls_ecp_group_id *g
 int mbedtls_oid_get_oid_by_ec_grp( mbedtls_ecp_group_id grp_id,
                            const char **oid, size_t *olen );
 #endif /* MBEDTLS_ECP_C */
+#endif
 
 #if defined(MBEDTLS_MD_C)
 /**
diff --git a/include/mbedtls/pk.h b/include/mbedtls/pk.h
index 7d0f977d5..536923409 100644
--- a/include/mbedtls/pk.h
+++ b/include/mbedtls/pk.h
@@ -47,6 +47,10 @@
 #include "psa/crypto.h"
 #endif
 
+#if defined(MBEDTLS_USE_TINYCRYPT)
+#include "tinycrypt/ecc.h"
+#endif
+
 #if ( defined(__ARMCC_VERSION) || defined(_MSC_VER) ) && \
     !defined(inline) && !defined(__cplusplus)
 #define inline __inline
@@ -179,6 +183,14 @@ typedef struct mbedtls_pk_debug_item
  */
 typedef struct mbedtls_pk_info_t mbedtls_pk_info_t;
 
+#if defined(MBEDTLS_USE_TINYCRYPT)
+typedef struct
+{
+    uint8_t private_key[NUM_ECC_BYTES];
+    uint8_t public_key[2*NUM_ECC_BYTES];
+} mbedtls_uecc_keypair;
+#endif
+
 /**
  * \brief           Public key container
  */
@@ -215,6 +227,15 @@ static inline mbedtls_rsa_context *mbedtls_pk_rsa( const mbedtls_pk_context pk )
 }
 #endif /* MBEDTLS_RSA_C */
 
+#if defined(MBEDTLS_USE_TINYCRYPT)
+
+static inline mbedtls_uecc_keypair *mbedtls_pk_uecc( const mbedtls_pk_context pk )
+{
+    return( (mbedtls_uecc_keypair *) (pk).pk_ctx );
+}
+
+#endif /* MBEDTLS_USE_TINYCRYPT */
+
 #if defined(MBEDTLS_ECP_C)
 /**
  * Quick access to an EC context inside a PK context.
diff --git a/include/mbedtls/pk_internal.h b/include/mbedtls/pk_internal.h
index 47f776770..f9b24c8d4 100644
--- a/include/mbedtls/pk_internal.h
+++ b/include/mbedtls/pk_internal.h
@@ -31,6 +31,88 @@
 
 #include "mbedtls/pk.h"
 
+/*
+ * PK information macro definitions
+ */
+
+/*
+ * Each PK type that can be used with MBEDTLS_PK_SINGLE_TYPE needs to have
+ * the following MBEDTLS_PK_INFO_{FIELD} definitions, plus a dummy one for the
+ * base name. For now, only ECKEY with MBEDTLS_USE_TINYCRYPT is defined.
+ *
+ * For optional functions that are omitted, we need both the _FUNC field
+ * defined to NULL, and an extra macro _OMIT defined to 1.
+ */
+
+#if defined(MBEDTLS_USE_TINYCRYPT)
+/* Dummy definition to keep check-names.sh happy - don't uncomment */
+//#define MBEDTLS_PK_INFO_ECKEY
+
+#define MBEDTLS_PK_INFO_ECKEY_CONTEXT           mbedtls_uecc_keypair
+#define MBEDTLS_PK_INFO_ECKEY_TYPE              MBEDTLS_PK_ECKEY
+#define MBEDTLS_PK_INFO_ECKEY_NAME              "EC"
+#define MBEDTLS_PK_INFO_ECKEY_GET_BITLEN        uecc_eckey_get_bitlen
+#define MBEDTLS_PK_INFO_ECKEY_CAN_DO            uecc_eckey_can_do
+#define MBEDTLS_PK_INFO_ECKEY_VERIFY_FUNC       uecc_eckey_verify_wrap
+#define MBEDTLS_PK_INFO_ECKEY_SIGN_FUNC         uecc_eckey_sign_wrap
+#define MBEDTLS_PK_INFO_ECKEY_DECRYPT_FUNC      NULL
+#define MBEDTLS_PK_INFO_ECKEY_DECRYPT_OMIT      1
+#define MBEDTLS_PK_INFO_ECKEY_ENCRYPT_FUNC      NULL
+#define MBEDTLS_PK_INFO_ECKEY_ENCRYPT_OMIT      1
+#define MBEDTLS_PK_INFO_ECKEY_CHECK_PAIR_FUNC   uecc_eckey_check_pair
+#define MBEDTLS_PK_INFO_ECKEY_CTX_ALLOC_FUNC    uecc_eckey_alloc_wrap
+#define MBEDTLS_PK_INFO_ECKEY_CTX_FREE_FUNC     uecc_eckey_free_wrap
+#define MBEDTLS_PK_INFO_ECKEY_DEBUG_FUNC        NULL
+#define MBEDTLS_PK_INFO_ECKEY_DEBUG_OMIT        1
+#endif /* MBEDTLS_USE_TINYCRYPT */
+
+/*
+ * Helper macros to extract fields from PK types
+ */
+#define MBEDTLS_PK_INFO_CONTEXT_T( PK )         PK ## _CONTEXT
+#define MBEDTLS_PK_INFO_TYPE_T( PK )            PK ## _TYPE
+#define MBEDTLS_PK_INFO_NAME_T( PK )            PK ## _NAME
+#define MBEDTLS_PK_INFO_GET_BITLEN_T( PK )      PK ## _GET_BITLEN
+#define MBEDTLS_PK_INFO_CAN_DO_T( PK )          PK ## _CAN_DO
+#define MBEDTLS_PK_INFO_VERIFY_FUNC_T( PK )     PK ## _VERIFY_FUNC
+#define MBEDTLS_PK_INFO_VERIFY_OMIT_T( PK )     PK ## _VERIFY_OMIT
+#define MBEDTLS_PK_INFO_SIGN_FUNC_T( PK )       PK ## _SIGN_FUNC
+#define MBEDTLS_PK_INFO_SIGN_OMIT_T( PK )       PK ## _SIGN_OMIT
+#define MBEDTLS_PK_INFO_DECRYPT_FUNC_T( PK )    PK ## _DECRYPT_FUNC
+#define MBEDTLS_PK_INFO_DECRYPT_OMIT_T( PK )    PK ## _DECRYPT_OMIT
+#define MBEDTLS_PK_INFO_ENCRYPT_FUNC_T( PK )    PK ## _ENCRYPT_FUNC
+#define MBEDTLS_PK_INFO_ENCRYPT_OMIT_T( PK )    PK ## _ENCRYPT_OMIT
+#define MBEDTLS_PK_INFO_CHECK_PAIR_FUNC_T( PK ) PK ## _CHECK_PAIR_FUNC
+#define MBEDTLS_PK_INFO_CHECK_PAIR_OMIT_T( PK ) PK ## _CHECK_PAIR_OMIT
+#define MBEDTLS_PK_INFO_CTX_ALLOC_FUNC_T( PK )  PK ## _CTX_ALLOC_FUNC
+#define MBEDTLS_PK_INFO_CTX_FREE_FUNC_T( PK )   PK ## _CTX_FREE_FUNC
+#define MBEDTLS_PK_INFO_DEBUG_FUNC_T( PK )      PK ## _DEBUG_FUNC
+#define MBEDTLS_PK_INFO_DEBUG_OMIT_T( PK )      PK ## _DEBUG_OMIT
+
+/* Wrappers around MBEDTLS_PK_INFO_{FIELD}_T() which makes sure that
+ * the argument is macro-expanded before concatenated with the
+ * field name. This allows to call these macros as
+ *    MBEDTLS_PK_INFO_{FIELD}( MBEDTLS_PK_SINGLE_TYPE ).
+ * where MBEDTLS_PK_SINGLE_TYPE expands to MBEDTLS_PK_INFO_{TYPE}. */
+#define MBEDTLS_PK_INFO_CONTEXT( PK )         MBEDTLS_PK_INFO_CONTEXT_T( PK )
+#define MBEDTLS_PK_INFO_TYPE( PK )            MBEDTLS_PK_INFO_TYPE_T( PK )
+#define MBEDTLS_PK_INFO_NAME( PK )            MBEDTLS_PK_INFO_NAME_T( PK )
+#define MBEDTLS_PK_INFO_GET_BITLEN( PK )      MBEDTLS_PK_INFO_GET_BITLEN_T( PK )
+#define MBEDTLS_PK_INFO_CAN_DO( PK )          MBEDTLS_PK_INFO_CAN_DO_T( PK )
+#define MBEDTLS_PK_INFO_VERIFY_FUNC( PK )     MBEDTLS_PK_INFO_VERIFY_FUNC_T( PK )
+#define MBEDTLS_PK_INFO_VERIFY_OMIT( PK )     MBEDTLS_PK_INFO_VERIFY_OMIT_T( PK )
+#define MBEDTLS_PK_INFO_SIGN_FUNC( PK )       MBEDTLS_PK_INFO_SIGN_FUNC_T( PK )
+#define MBEDTLS_PK_INFO_SIGN_OMIT( PK )       MBEDTLS_PK_INFO_SIGN_OMIT_T( PK )
+#define MBEDTLS_PK_INFO_DECRYPT_FUNC( PK )    MBEDTLS_PK_INFO_DECRYPT_FUNC_T( PK )
+#define MBEDTLS_PK_INFO_DECRYPT_OMIT( PK )    MBEDTLS_PK_INFO_DECRYPT_OMIT_T( PK )
+#define MBEDTLS_PK_INFO_ENCRYPT_FUNC( PK )    MBEDTLS_PK_INFO_ENCRYPT_FUNC_T( PK )
+#define MBEDTLS_PK_INFO_ENCRYPT_OMIT( PK )    MBEDTLS_PK_INFO_ENCRYPT_OMIT_T( PK )
+#define MBEDTLS_PK_INFO_CHECK_PAIR_FUNC( PK ) MBEDTLS_PK_INFO_CHECK_PAIR_FUNC_T( PK )
+#define MBEDTLS_PK_INFO_CHECK_PAIR_OMIT( PK ) MBEDTLS_PK_INFO_CHECK_PAIR_OMIT_T( PK )
+#define MBEDTLS_PK_INFO_CTX_ALLOC_FUNC( PK )  MBEDTLS_PK_INFO_CTX_ALLOC_FUNC_T( PK )
+#define MBEDTLS_PK_INFO_CTX_FREE_FUNC( PK )   MBEDTLS_PK_INFO_CTX_FREE_FUNC_T( PK )
+#define MBEDTLS_PK_INFO_DEBUG_FUNC( PK )      MBEDTLS_PK_INFO_DEBUG_FUNC_T( PK )
+#define MBEDTLS_PK_INFO_DEBUG_OMIT( PK )      MBEDTLS_PK_INFO_DEBUG_OMIT_T( PK )
 struct mbedtls_pk_info_t
 {
     /** Public key type */
@@ -105,6 +187,48 @@ struct mbedtls_pk_info_t
     void (*debug_func)( const void *ctx, mbedtls_pk_debug_item *items );
 
 };
+
+/**
+ * \brief   This macro builds an instance of ::mbedtls_pk_info_t
+ *          from an \c MBEDTLS_PK_INFO_{TYPE} identifier.
+ */
+#if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
+#define MBEDTLS_PK_INFO( PK )                           \
+{                                                       \
+    MBEDTLS_PK_INFO_TYPE( PK ),              \
+    MBEDTLS_PK_INFO_NAME( PK ),              \
+    MBEDTLS_PK_INFO_GET_BITLEN( PK ),        \
+    MBEDTLS_PK_INFO_CAN_DO( PK ),            \
+    MBEDTLS_PK_INFO_VERIFY_FUNC( PK ),       \
+    MBEDTLS_PK_INFO_SIGN_FUNC( PK ),         \
+    NULL,                                               \
+    NULL,                                               \
+    MBEDTLS_PK_INFO_DECRYPT_FUNC( PK ),      \
+    MBEDTLS_PK_INFO_ENCRYPT_FUNC( PK ),      \
+    MBEDTLS_PK_INFO_CHECK_PAIR_FUNC( PK ),   \
+    MBEDTLS_PK_INFO_CTX_ALLOC_FUNC( PK ),    \
+    MBEDTLS_PK_INFO_CTX_FREE_FUNC( PK ),     \
+    NULL,                                               \
+    NULL,                                               \
+    MBEDTLS_PK_INFO_DEBUG_FUNC( PK ),        \
+}
+#else /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
+#define MBEDTLS_PK_INFO( PK )                           \
+{                                                       \
+    MBEDTLS_PK_INFO_TYPE( PK ),              \
+    MBEDTLS_PK_INFO_NAME( PK ),              \
+    MBEDTLS_PK_INFO_GET_BITLEN( PK ),        \
+    MBEDTLS_PK_INFO_CAN_DO( PK ),            \
+    MBEDTLS_PK_INFO_VERIFY_FUNC( PK ),       \
+    MBEDTLS_PK_INFO_SIGN_FUNC( PK ),         \
+    MBEDTLS_PK_INFO_DECRYPT_FUNC( PK ),      \
+    MBEDTLS_PK_INFO_ENCRYPT_FUNC( PK ),      \
+    MBEDTLS_PK_INFO_CHECK_PAIR_FUNC( PK ),   \
+    MBEDTLS_PK_INFO_CTX_ALLOC_FUNC( PK ),    \
+    MBEDTLS_PK_INFO_CTX_FREE_FUNC( PK ),     \
+    MBEDTLS_PK_INFO_DEBUG_FUNC( PK ),        \
+}
+#endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
 #if defined(MBEDTLS_PK_RSA_ALT_SUPPORT)
 /* Container for RSA-alt */
 typedef struct
@@ -129,6 +253,10 @@ extern const mbedtls_pk_info_t mbedtls_eckeydh_info;
 extern const mbedtls_pk_info_t mbedtls_ecdsa_info;
 #endif
 
+#if defined(MBEDTLS_USE_TINYCRYPT)
+extern const mbedtls_pk_info_t mbedtls_uecc_eckey_info;
+#endif
+
 #if defined(MBEDTLS_PK_RSA_ALT_SUPPORT)
 extern const mbedtls_pk_info_t mbedtls_rsa_alt_info;
 #endif
diff --git a/include/mbedtls/platform.h b/include/mbedtls/platform.h
index fde5ee8c8..00d5c5756 100644
--- a/include/mbedtls/platform.h
+++ b/include/mbedtls/platform.h
@@ -37,6 +37,10 @@
 #include MBEDTLS_CONFIG_FILE
 #endif
 
+#define MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED     -0x0070 /**< Hardware accelerator failed */
+#define MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED -0x0072 /**< The requested feature is not supported by the platform */
+#define MBEDTLS_ERR_PLATFORM_FAULT_DETECTED      -0x0071 /**< A hardware fault was detected in a critical path. As a security precaution this should be treated as a potential physical attack */
+#define MBEDTLS_ERR_PLATFORM_ALLOC_FAILED        -0x0076 /**< Memory allocation failed */
 #if defined(MBEDTLS_HAVE_TIME)
 #include "mbedtls/platform_time.h"
 #endif
diff --git a/include/mbedtls/platform_util.h b/include/mbedtls/platform_util.h
index fbc2a0d1c..7580d6e57 100644
--- a/include/mbedtls/platform_util.h
+++ b/include/mbedtls/platform_util.h
@@ -132,6 +132,178 @@ MBEDTLS_DEPRECATED typedef int mbedtls_deprecated_numeric_constant_t;
 #endif /* MBEDTLS_DEPRECATED_WARNING */
 #endif /* MBEDTLS_DEPRECATED_REMOVED */
 
+#if defined(MBEDTLS_USE_TINYCRYPT)
+/**
+ * \brief       Securely zeroize a buffer
+ *
+ *              The function is meant to wipe the data contained in a buffer so
+ *              that it can no longer be recovered even if the program memory
+ *              is later compromised. Call this function on sensitive data
+ *              stored on the stack before returning from a function, and on
+ *              sensitive data stored on the heap before freeing the heap
+ *              object.
+ *
+ *              It is extremely difficult to guarantee that calls to
+ *              mbedtls_platform_zeroize() are not removed by aggressive
+ *              compiler optimizations in a portable way. For this reason, Mbed
+ *              TLS provides the configuration option
+ *              MBEDTLS_PLATFORM_ZEROIZE_ALT, which allows users to configure
+ *              mbedtls_platform_zeroize() to use a suitable implementation for
+ *              their platform and needs
+ *
+ * \param buf   Buffer to be zeroized
+ * \param len   Length of the buffer in bytes
+ *
+ * \return      The value of \p buf if the operation was successful.
+ * \return      NULL if a potential FI attack was detected or input parameters
+ *              are not valid.
+ */
+void *mbedtls_platform_zeroize( void *buf, size_t len );
+
+/**
+ * \brief       Secure memset
+ *
+ *              This is a constant-time version of memset(). The buffer is
+ *              initialised with random data and the order is also randomised
+ *              using the RNG in order to further harden against side-channel
+ *              attacks.
+ *
+ * \param ptr   Buffer to be set.
+ * \param value Value to be used when setting the buffer.
+ * \param num   The length of the buffer in bytes.
+ *
+ * \return      The value of \p ptr if the operation was successful.
+ * \return      NULL if a potential FI attack was detected.
+ */
+void *mbedtls_platform_memset( void *ptr, int value, size_t num );
+
+/**
+ * \brief       Secure memcpy
+ *
+ *              This is a constant-time version of memcpy(). The buffer is
+ *              initialised with random data and the order is also randomised
+ *              using the RNG in order to further harden against side-channel
+ *              attacks.
+ *
+ * \param dst   Destination buffer where the data is being copied to.
+ * \param src   Source buffer where the data is being copied from.
+ * \param num   The length of the buffers in bytes.
+ *
+ * \return      The value of \p dst.
+ * \return      NULL if a potential FI attack was detected.
+ */
+void *mbedtls_platform_memcpy( void *dst, const void *src, size_t num );
+
+/**
+ * \brief       Secure memmove
+ *
+ *              This is a constant-time version of memmove(). It is based on
+ *              the double use of the mbedtls_platform_memcpy() function secured
+ *              against side-channel attacks.
+ *
+ * \param dst   Destination buffer where the data is being moved to.
+ * \param src   Source buffer where the data is being moved from.
+ * \param num   The length of the buffers in bytes.
+ *
+ * \return      0 if the operation was successful
+ * \return      #MBEDTLS_ERR_PLATFORM_ALLOC_FAILED if a memory allocation failed
+ */
+int mbedtls_platform_memmove( void *dst, const void *src, size_t num );
+
+#if !defined(MBEDTLS_DEPRECATED_REMOVED)
+#if defined(MBEDTLS_DEPRECATED_WARNING)
+#define MBEDTLS_DEPRECATED      __attribute__((deprecated))
+#else
+#define MBEDTLS_DEPRECATED
+#endif
+
+/**
+ * \brief       Secure memcmp
+ *
+ *              This is a constant-time version of memcmp(), but without checking
+ *              if the bytes are greater or lower. The order is also randomised
+ *              using the RNG in order to further harden against side-channel attacks.
+ *
+ * \param buf1  First buffer to compare.
+ * \param buf2  Second buffer to compare against.
+ * \param num   The length of the buffers in bytes.
+ *
+ * \deprecated  Superseded by mbedtls_platform_memequal(), and is only an alias to it.
+ *
+ * \return      0 if the buffers were equal or an unspecified non-zero value
+ *              otherwise.
+ */
+int mbedtls_platform_memcmp( const void *buf1, const void *buf2, size_t num );
+
+#endif
+/**
+ * \brief       Secure check if the buffers have the same data.
+ *
+ *              This is a constant-time version of memcmp(), but without checking
+ *              if the bytes are greater or lower. The order is also randomised
+ *              using the RNG in order to further harden against side-channel attacks.
+ *
+ * \param buf1  First buffer to compare.
+ * \param buf2  Second buffer to compare against.
+ * \param num   The length of the buffers in bytes.
+ *
+ * \return      0 if the buffers were equal or an unspecified non-zero value
+ *              otherwise.
+ */
+int mbedtls_platform_memequal( const void *buf1, const void *buf2, size_t num );
+
+/**
+ * \brief       RNG-function for getting a random 32-bit integer.
+ *
+ * \return      The generated random number.
+ */
+uint32_t mbedtls_platform_random_uint32( void );
+
+/**
+ * \brief       RNG-function for getting a random in given range.
+ *
+ *              This function is meant to provide a global RNG to be used
+ *              throughout Mbed TLS for hardening the library. It is used
+ *              for generating a random delay, random data or random offset
+ *              for utility functions. It is not meant to be a
+ *              cryptographically secure RNG, but provide an RNG for utility
+ *              functions.
+ *
+ * \param num   Max-value for the generated random number, exclusive.
+ *              Must be greater than zero, otherwise an undefined behavior
+ *              will occur on "num % 0".
+ *              The generated number will be on range [0, num).
+ *
+ * \return      The generated random number.
+ */
+uint32_t mbedtls_platform_random_in_range( uint32_t num );
+
+/**
+ * \brief       Random delay function.
+ *
+ *              Function implements a random delay by incrementing a local
+ *              variable randomized number of times (busy-looping).
+ *
+ *              Duration of the delay is random as number of variable increments
+ *              is randomized.
+ *
+ * \note        This function works only if the MBEDTLS_FI_COUNTERMEASURES flag
+ *              is defined in the configuration. Otherwise, the function does
+ *              nothing.
+ */
+void mbedtls_platform_random_delay( void );
+
+/**
+ * \brief       RNG-function for getting a random buffer.
+ *
+ * \param buf   Buffer for random data
+ * \param len   Length of the buffer in bytes
+ *
+ */
+void mbedtls_platform_random_buf( uint8_t *buf, size_t len);
+
+#else
+
 /**
  * \brief       Securely zeroize a buffer
  *
@@ -156,6 +328,8 @@ MBEDTLS_DEPRECATED typedef int mbedtls_deprecated_numeric_constant_t;
  */
 void mbedtls_platform_zeroize( void *buf, size_t len );
 
+#endif
+
 #if defined(MBEDTLS_HAVE_TIME_DATE)
 /**
  * \brief      Platform-specific implementation of gmtime_r()
diff --git a/include/tinycrypt/ecc.h b/include/tinycrypt/ecc.h
new file mode 100755
index 000000000..cdb5762a2
--- /dev/null
+++ b/include/tinycrypt/ecc.h
@@ -0,0 +1,479 @@
+/* ecc.h - TinyCrypt interface to common ECC functions */
+
+/*
+ *  Copyright (c) 2019, Arm Limited (or its affiliates), All Rights Reserved.
+ *  SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/* Copyright (c) 2014, Kenneth MacKay
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * * Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *  Copyright (C) 2017 by Intel Corporation, All Rights Reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *    - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *    - Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ *    - Neither the name of Intel Corporation nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ * @brief -- Interface to common ECC functions.
+ *
+ *  Overview: This software is an implementation of common functions
+ *            necessary to elliptic curve cryptography. This implementation uses
+ *            curve NIST p-256.
+ *
+ *  Security: The curve NIST p-256 provides approximately 128 bits of security.
+ *
+ */
+
+#ifndef __TC_UECC_H__
+#define __TC_UECC_H__
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Return values for functions, chosen with large Hamming distances between
+ * them (especially to SUCESS) to mitigate the impact of fault injection
+ * attacks flipping a low number of bits. */
+#define UECC_SUCCESS            0xCD
+#define UECC_FAILURE            0x52
+#define UECC_FAULT_DETECTED     0x3B
+
+/* Word size (4 bytes considering 32-bits architectures) */
+#define uECC_WORD_SIZE 4
+
+/* setting max number of calls to prng: */
+#ifndef uECC_RNG_MAX_TRIES
+#define uECC_RNG_MAX_TRIES 64
+#endif
+
+/* defining data types to store word and bit counts: */
+typedef int_fast8_t wordcount_t;
+typedef int_fast16_t bitcount_t;
+/* defining data type for comparison result: */
+typedef int_fast8_t cmpresult_t;
+/* defining data type to store ECC coordinate/point in 32bits words: */
+typedef unsigned int uECC_word_t;
+/* defining data type to store an ECC coordinate/point in 64bits words: */
+typedef uint64_t uECC_dword_t;
+
+/* defining masks useful for ecc computations: */
+#define HIGH_BIT_SET 0x80000000
+#define uECC_WORD_BITS 32
+#define uECC_WORD_BITS_SHIFT 5
+#define uECC_WORD_BITS_MASK 0x01F
+
+/* Number of words of 32 bits to represent an element of the the curve p-256: */
+#define NUM_ECC_WORDS 8
+/* Number of bytes to represent an element of the the curve p-256: */
+#define NUM_ECC_BYTES (uECC_WORD_SIZE*NUM_ECC_WORDS)
+#define NUM_ECC_BITS 256
+
+/*
+ * @brief computes doubling of point ion jacobian coordinates, in place.
+ * @param X1 IN/OUT -- x coordinate
+ * @param Y1 IN/OUT -- y coordinate
+ * @param Z1 IN/OUT -- z coordinate
+ * @param curve IN -- elliptic curve
+ */
+void double_jacobian_default(uECC_word_t * X1, uECC_word_t * Y1,
+			     uECC_word_t * Z1);
+
+/*
+ * @brief Computes result = product % curve_p
+ * from http://www.nsa.gov/ia/_files/nist-routines.pdf
+ * @param result OUT -- product % curve_p
+ * @param product IN -- value to be reduced mod curve_p
+ */
+void vli_mmod_fast_secp256r1(unsigned int *result, unsigned int *product);
+
+/* Bytes to words ordering: */
+#define BYTES_TO_WORDS_8(a, b, c, d, e, f, g, h) 0x##d##c##b##a, 0x##h##g##f##e
+#define BYTES_TO_WORDS_4(a, b, c, d) 0x##d##c##b##a
+#define BITS_TO_WORDS(num_bits) \
+	((num_bits + ((uECC_WORD_SIZE * 8) - 1)) / (uECC_WORD_SIZE * 8))
+#define BITS_TO_BYTES(num_bits) ((num_bits + 7) / 8)
+
+extern const uECC_word_t curve_p[NUM_ECC_WORDS];
+extern const uECC_word_t curve_n[NUM_ECC_WORDS];
+extern const uECC_word_t curve_G[2 * NUM_ECC_WORDS];
+extern const uECC_word_t curve_b[NUM_ECC_WORDS];
+
+/*
+ * @brief Generates a random integer in the range 0 < random < top.
+ * Both random and top have num_words words.
+ * @param random OUT -- random integer in the range 0 < random < top
+ * @param top IN -- upper limit
+ * @param num_words IN -- number of words
+ * @return UECC_SUCCESS in case of success
+ * @return UECC_FAILURE upon failure
+ */
+int uECC_generate_random_int(uECC_word_t *random, const uECC_word_t *top,
+			     wordcount_t num_words);
+
+
+/* uECC_RNG_Function type
+ * The RNG function should fill 'size' random bytes into 'dest'. It should
+ * return 'size' if 'dest' was filled with random data of 'size' length, or 0
+ * if the random data could not be generated. The filled-in values should be
+ * either truly random, or from a cryptographically-secure PRNG.
+ *
+ * A correctly functioning RNG function must be set (using uECC_set_rng())
+ * before calling uECC_make_key() or uECC_sign().
+ *
+ * Setting a correctly functioning RNG function improves the resistance to
+ * side-channel attacks for uECC_shared_secret().
+ *
+ * A correct RNG function is set by default. If you are building on another
+ * POSIX-compliant system that supports /dev/random or /dev/urandom, you can
+ * define uECC_POSIX to use the predefined RNG.
+ */
+typedef int(*uECC_RNG_Function)(uint8_t *dest, unsigned int size);
+
+/*
+ * @brief Set the function that will be used to generate random bytes. The RNG
+ * function should return 'size' if the random data of length 'size' was
+ * generated, or 0 if the random data could not be generated.
+ *
+ * @note On platforms where there is no predefined RNG function, this must be
+ * called before uECC_make_key() or uECC_sign() are used.
+ *
+ * @param rng_function IN -- function that will be used to generate random bytes
+ */
+void uECC_set_rng(uECC_RNG_Function rng_function);
+
+/*
+ * @brief provides current uECC_RNG_Function.
+ * @return Returns the function that will be used to generate random bytes.
+ */
+uECC_RNG_Function uECC_get_rng(void);
+
+/*
+ * @brief computes the size of a private key for the curve in bytes.
+ * @param curve IN -- elliptic curve
+ * @return size of a private key for the curve in bytes.
+ */
+int uECC_curve_private_key_size(void);
+
+/*
+ * @brief computes the size of a public key for the curve in bytes.
+ * @param curve IN -- elliptic curve
+ * @return the size of a public key for the curve in bytes.
+ */
+int uECC_curve_public_key_size(void);
+
+/*
+ * @brief Compute the corresponding public key for a private key.
+ * @param private_key IN -- The private key to compute the public key for
+ * @param public_key OUT -- Will be filled in with the corresponding public key
+ * @param curve
+ * @return UECC_SUCCESS or UECC_FAILURE or UECC_FAULT_DETECTED
+ */
+int uECC_compute_public_key(const uint8_t *private_key,
+			    uint8_t *public_key);
+
+/*
+ * @brief Compute public-key.
+ * @return corresponding public-key.
+ * @param result OUT -- public-key
+ * @param private_key IN -- private-key
+ * @param curve IN -- elliptic curve
+ * @return UECC_SUCCESS or UECC_FAILURE or UECC_FAULT_DETECTED
+ */
+uECC_word_t EccPoint_compute_public_key(uECC_word_t *result,
+					uECC_word_t *private_key);
+
+/*
+ * @brief Point multiplication algorithm using Montgomery's ladder with co-Z
+ * coordinates. See http://eprint.iacr.org/2011/338.pdf.
+ * Uses scalar regularization and coordinate randomization (if a global RNG
+ * function is set) in order to protect against some side channel attacks.
+ * @note Result may overlap point.
+ * @param result OUT -- returns scalar*point
+ * @param point IN -- elliptic curve point
+ * @param scalar IN -- scalar
+ * @return UECC_SUCCESS or UECC_FAILURE or UECC_FAULT_DETECTED
+ */
+int EccPoint_mult_safer(uECC_word_t * result, const uECC_word_t * point,
+			const uECC_word_t * scalar);
+
+/*
+ * @brief Constant-time comparison to zero - secure way to compare long integers
+ * @param vli IN -- very long integer
+ * @param num_words IN -- number of words in the vli
+ * @return 1 if vli == 0, 0 otherwise.
+ */
+uECC_word_t uECC_vli_isZero(const uECC_word_t *vli);
+
+/*
+ * @brief Check if 'point' is the point at infinity
+ * @param point IN -- elliptic curve point
+ * @return if 'point' is the point at infinity, 0 otherwise.
+ */
+uECC_word_t EccPoint_isZero(const uECC_word_t *point);
+
+/*
+ * @brief computes the sign of left - right, in constant time.
+ * @param left IN -- left term to be compared
+ * @param right IN -- right term to be compared
+ * @param num_words IN -- number of words
+ * @return the sign of left - right
+ */
+cmpresult_t uECC_vli_cmp(const uECC_word_t *left, const uECC_word_t *right);
+
+/*
+ * @brief computes sign of left - right, not in constant time.
+ * @note should not be used if inputs are part of a secret
+ * @param left IN -- left term to be compared
+ * @param right IN -- right term to be compared
+ * @param num_words IN -- number of words
+ * @return the sign of left - right
+ */
+cmpresult_t uECC_vli_cmp_unsafe(const uECC_word_t *left, const uECC_word_t *right);
+
+/*
+ * @brief Computes result = (left - right) % mod.
+ * @note Assumes that (left < mod) and (right < mod), and that result does not
+ * overlap mod.
+ * @param result OUT -- (left - right) % mod
+ * @param left IN -- leftright term in modular subtraction
+ * @param right IN -- right term in modular subtraction
+ * @param mod IN -- mod
+ * @param num_words IN -- number of words
+ */
+void uECC_vli_modSub(uECC_word_t *result, const uECC_word_t *left,
+		     const uECC_word_t *right, const uECC_word_t *mod);
+
+/*
+ * @brief Computes P' = (x1', y1', Z3), P + Q = (x3, y3, Z3) or
+ * P => P', Q => P + Q
+ * @note assumes Input P = (x1, y1, Z), Q = (x2, y2, Z)
+ * @param X1 IN -- x coordinate of P
+ * @param Y1 IN -- y coordinate of P
+ * @param X2 IN -- x coordinate of Q
+ * @param Y2 IN -- y coordinate of Q
+ * @param curve IN -- elliptic curve
+ */
+void XYcZ_add(uECC_word_t * X1, uECC_word_t * Y1, uECC_word_t * X2,
+	      uECC_word_t * Y2);
+
+/*
+ * @brief Computes (x1 * z^2, y1 * z^3)
+ * @param X1 IN -- previous x1 coordinate
+ * @param Y1 IN -- previous y1 coordinate
+ * @param Z IN -- z value
+ * @param curve IN -- elliptic curve
+ */
+void apply_z(uECC_word_t * X1, uECC_word_t * Y1, const uECC_word_t * const Z);
+
+/*
+ * @brief Check if bit is set.
+ * @return Returns nonzero if bit 'bit' of vli is set.
+ * @warning It is assumed that the value provided in 'bit' is within the
+ * boundaries of the word-array 'vli'.
+ * @note The bit ordering layout assumed for vli is: {31, 30, ..., 0},
+ * {63, 62, ..., 32}, {95, 94, ..., 64}, {127, 126,..., 96} for a vli consisting
+ * of 4 uECC_word_t elements.
+ */
+uECC_word_t uECC_vli_testBit(const uECC_word_t *vli, bitcount_t bit);
+
+/*
+ * @brief Computes result = product % mod, where product is 2N words long.
+ * @param result OUT -- product % mod
+ * @param mod IN -- module
+ * @param num_words IN -- number of words
+ * @warning Currently only designed to work for curve_p or curve_n.
+ */
+void uECC_vli_mmod(uECC_word_t *result, uECC_word_t *product,
+		   const uECC_word_t *mod);
+
+/*
+ * @brief Computes modular product (using curve->mmod_fast)
+ * @param result OUT -- (left * right) mod % curve_p
+ * @param left IN -- left term in product
+ * @param right IN -- right term in product
+ * @param curve IN -- elliptic curve
+ */
+void uECC_vli_modMult_fast(uECC_word_t *result, const uECC_word_t *left,
+			   const uECC_word_t *right);
+
+/*
+ * @brief Computes result = left - right.
+ * @note Can modify in place.
+ * @param result OUT -- left - right
+ * @param left IN -- left term in subtraction
+ * @param right IN -- right term in subtraction
+ * @param num_words IN -- number of words
+ * @return borrow
+ */
+uECC_word_t uECC_vli_sub(uECC_word_t *result, const uECC_word_t *left,
+			 const uECC_word_t *right);
+
+/*
+ * @brief Constant-time comparison function(secure way to compare long ints)
+ * @param left IN -- left term in comparison
+ * @param right IN -- right term in comparison
+ * @param num_words IN -- number of words
+ * @return Returns 0 if left == right, non-zero otherwise.
+ */
+uECC_word_t uECC_vli_equal(const uECC_word_t *left, const uECC_word_t *right);
+
+/*
+ * @brief Computes (left * right) % mod
+ * @param result OUT -- (left * right) % mod
+ * @param left IN -- left term in product
+ * @param right IN -- right term in product
+ * @param mod IN -- mod
+ * @param num_words IN -- number of words
+ */
+void uECC_vli_modMult(uECC_word_t *result, const uECC_word_t *left,
+		      const uECC_word_t *right, const uECC_word_t *mod);
+
+/*
+ * @brief Computes (1 / input) % mod
+ * @note All VLIs are the same size.
+ * @note See "Euclid's GCD to Montgomery Multiplication to the Great Divide"
+ * @param result OUT -- (1 / input) % mod
+ * @param input IN -- value to be modular inverted
+ * @param mod IN -- mod
+ * @param num_words -- number of words
+ */
+void uECC_vli_modInv(uECC_word_t *result, const uECC_word_t *input,
+		     const uECC_word_t *mod);
+
+/*
+ * @brief Sets dest = src.
+ * @param dest OUT -- destination buffer
+ * @param src IN --  origin buffer
+ * @param num_words IN -- number of words
+ */
+void uECC_vli_set(uECC_word_t *dest, const uECC_word_t *src);
+
+/*
+ * @brief Computes (left + right) % mod.
+ * @note Assumes that (left < mod) and right < mod), and that result does not
+ * overlap mod.
+ * @param result OUT -- (left + right) % mod.
+ * @param left IN -- left term in addition
+ * @param right IN -- right term in addition
+ * @param mod IN -- mod
+ * @param num_words IN -- number of words
+ */
+void uECC_vli_modAdd(uECC_word_t *result,  const uECC_word_t *left,
+    		     const uECC_word_t *right, const uECC_word_t *mod);
+
+/*
+ * @brief Counts the number of bits required to represent vli.
+ * @param vli IN -- very long integer
+ * @param max_words IN -- number of words
+ * @return number of bits in given vli
+ */
+bitcount_t uECC_vli_numBits(const uECC_word_t *vli);
+
+/*
+ * @brief Erases (set to 0) vli
+ * @param vli IN -- very long integer
+ * @param num_words IN -- number of words
+ */
+void uECC_vli_clear(uECC_word_t *vli);
+
+/*
+ * @brief check if it is a valid point in the curve
+ * @param point IN -- point to be checked
+ * @param curve IN -- elliptic curve
+ * @return 0 if point is valid
+ * @exception returns -1 if it is a point at infinity
+ * @exception returns -2 if x or y is smaller than p,
+ * @exception returns -3 if y^2 != x^3 + ax + b.
+ */
+int uECC_valid_point(const uECC_word_t *point);
+
+/*
+ * @brief Check if a public key is valid.
+ * @param public_key IN -- The public key to be checked.
+ * @return returns 0 if the public key is valid
+ * @exception returns -1 if it is a point at infinity
+ * @exception returns -2 if x or y is smaller than p,
+ * @exception returns -3 if y^2 != x^3 + ax + b.
+ * @exception returns -4 if public key is the group generator.
+ *
+ * @note Note that you are not required to check for a valid public key before
+ * using any other uECC functions. However, you may wish to avoid spending CPU
+ * time computing a shared secret or verifying a signature using an invalid
+ * public key.
+ */
+int uECC_valid_public_key(const uint8_t *public_key);
+
+ /*
+  * @brief Converts an integer in uECC native format to big-endian bytes.
+  * @param bytes OUT -- bytes representation
+  * @param num_bytes IN -- number of bytes
+  * @param native IN -- uECC native representation
+  */
+void uECC_vli_nativeToBytes(uint8_t *bytes, int num_bytes,
+    			    const unsigned int *native);
+
+/*
+ * @brief Converts big-endian bytes to an integer in uECC native format.
+ * @param native OUT -- uECC native representation
+ * @param bytes IN -- bytes representation
+ * @param num_bytes IN -- number of bytes
+ */
+void uECC_vli_bytesToNative(unsigned int *native, const uint8_t *bytes,
+			    int num_bytes);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __TC_UECC_H__ */
diff --git a/include/tinycrypt/ecc_dh.h b/include/tinycrypt/ecc_dh.h
new file mode 100755
index 000000000..c443f8536
--- /dev/null
+++ b/include/tinycrypt/ecc_dh.h
@@ -0,0 +1,134 @@
+/* ecc_dh.h - TinyCrypt interface to EC-DH implementation */
+
+/*
+ *  Copyright (c) 2019, Arm Limited (or its affiliates), All Rights Reserved.
+ *  SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*
+ * Copyright (c) 2014, Kenneth MacKay
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * * Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Copyright (C) 2017 by Intel Corporation, All Rights Reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *    - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *    - Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ *    - Neither the name of Intel Corporation nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ * @brief -- Interface to EC-DH implementation.
+ *
+ *  Overview: This software is an implementation of EC-DH. This implementation
+ *            uses curve NIST p-256.
+ *
+ *  Security: The curve NIST p-256 provides approximately 128 bits of security.
+ */
+
+#ifndef __TC_ECC_DH_H__
+#define __TC_ECC_DH_H__
+
+#include <tinycrypt/ecc.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Create a public/private key pair.
+ * @return UECC_SUCCESS or UECC_FAILURE or UECC_FAULT_DETECTED
+ *
+ * @param p_public_key OUT -- Will be filled in with the public key. Must be at
+ * least 2 * the curve size (in bytes) long. For curve secp256r1, p_public_key
+ * must be 64 bytes long.
+ * @param p_private_key OUT -- Will be filled in with the private key. Must be as
+ * long as the curve order (for secp256r1, p_private_key must be 32 bytes long).
+ *
+ * @note side-channel countermeasure: algorithm strengthened against timing
+ * attack.
+ * @warning A cryptographically-secure PRNG function must be set (using
+ * uECC_set_rng()) before calling uECC_make_key().
+ */
+int uECC_make_key(uint8_t *p_public_key, uint8_t *p_private_key);
+
+#ifdef ENABLE_TESTS
+
+/**
+ * @brief Create a public/private key pair given a specific d.
+ *
+ * @note THIS FUNCTION SHOULD BE CALLED ONLY FOR TEST PURPOSES. Refer to
+ * uECC_make_key() function for real applications.
+ */
+int uECC_make_key_with_d(uint8_t *p_public_key, uint8_t *p_private_key,
+    			 unsigned int *d);
+#endif
+
+/**
+ * @brief Compute a shared secret given your secret key and someone else's
+ * public key.
+ * @return UECC_SUCCESS or UECC_FAILURE or UECC_FAULT_DETECTED
+ *
+ * @param p_secret OUT -- Will be filled in with the shared secret value. Must be
+ * the same size as the curve size (for curve secp256r1, secret must be 32 bytes
+ * long.
+ * @param p_public_key IN -- The public key of the remote party.
+ * @param p_private_key IN -- Your private key.
+ *
+ * @warning It is recommended to use the output of uECC_shared_secret() as the
+ * input of a recommended Key Derivation Function (see NIST SP 800-108) in
+ * order to produce a cryptographically secure symmetric key.
+ */
+int uECC_shared_secret(const uint8_t *p_public_key, const uint8_t *p_private_key,
+		       uint8_t *p_secret);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __TC_ECC_DH_H__ */
diff --git a/include/tinycrypt/ecc_dsa.h b/include/tinycrypt/ecc_dsa.h
new file mode 100755
index 000000000..30cbe5eef
--- /dev/null
+++ b/include/tinycrypt/ecc_dsa.h
@@ -0,0 +1,142 @@
+/* ecc_dh.h - TinyCrypt interface to EC-DSA implementation */
+
+/*
+ *  Copyright (c) 2019, Arm Limited (or its affiliates), All Rights Reserved.
+ *  SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*
+ * Copyright (c) 2014, Kenneth MacKay
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * * Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Copyright (C) 2017 by Intel Corporation, All Rights Reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *    - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *    - Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ *    - Neither the name of Intel Corporation nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @file
+ * @brief -- Interface to EC-DSA implementation.
+ *
+ *  Overview: This software is an implementation of EC-DSA. This implementation
+ *            uses curve NIST p-256.
+ *
+ *  Security: The curve NIST p-256 provides approximately 128 bits of security.
+ *
+ *  Usage:  - To sign: Compute a hash of the data you wish to sign (SHA-2 is
+ *          recommended) and pass it in to ecdsa_sign function along with your
+ *          private key and a random number. You must use a new non-predictable
+ *          random number to generate each new signature.
+ *          - To verify a signature: Compute the hash of the signed data using
+ *          the same hash as the signer and pass it to this function along with
+ *          the signer's public key and the signature values (r and s).
+ */
+
+#ifndef __TC_ECC_DSA_H__
+#define __TC_ECC_DSA_H__
+
+#include <tinycrypt/ecc.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Generate an ECDSA signature for a given hash value.
+ * @return UECC_SUCCESS or UECC_FAILURE or UECC_FAULT_DETECTED
+ *
+ * @param p_private_key IN -- Your private key.
+ * @param p_message_hash IN -- The hash of the message to sign.
+ * @param p_hash_size IN -- The size of p_message_hash in bytes.
+ * @param p_signature OUT -- Will be filled in with the signature value. Must be
+ * at least 2 * curve size long (for secp256r1, signature must be 64 bytes long).
+ *
+ * @warning A cryptographically-secure PRNG function must be set (using
+ * uECC_set_rng()) before calling uECC_sign().
+ * @note Usage: Compute a hash of the data you wish to sign (SHA-2 is
+ * recommended) and pass it in to this function along with your private key.
+ * @note side-channel countermeasure: algorithm strengthened against timing
+ * attack.
+ */
+int uECC_sign(const uint8_t *p_private_key, const uint8_t *p_message_hash,
+	      unsigned p_hash_size, uint8_t *p_signature);
+
+#ifdef ENABLE_TESTS
+/*
+ * THIS FUNCTION SHOULD BE CALLED FOR TEST PURPOSES ONLY.
+ * Refer to uECC_sign() function for real applications.
+ */
+int uECC_sign_with_k(const uint8_t *private_key, const uint8_t *message_hash,
+		     unsigned int hash_size, uECC_word_t *k, uint8_t *signature);
+#endif
+
+/**
+ * @brief Verify an ECDSA signature.
+ * @return returns UECC_SUCCESS if the signature is valid
+ * 	   returns UECC_FAILURE if the signature is invalid.
+ *
+ * @param p_public_key IN -- The signer's public key.
+ * @param p_message_hash IN -- The hash of the signed data.
+ * @param p_hash_size IN -- The size of p_message_hash in bytes.
+ * @param p_signature IN -- The signature values.
+ *
+ * @note Usage: Compute the hash of the signed data using the same hash as the
+ * signer and pass it to this function along with the signer's public key and
+ * the signature values (hash_size and signature).
+ */
+int uECC_verify(const uint8_t *p_public_key, const uint8_t *p_message_hash,
+		unsigned int p_hash_size, const uint8_t *p_signature);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __TC_ECC_DSA_H__ */
diff --git a/library/oid.c b/library/oid.c
index 19c8ac207..556f8fbed 100644
--- a/library/oid.c
+++ b/library/oid.c
@@ -40,6 +40,7 @@
  * Macro to automatically add the size of #define'd OIDs
  */
 #define ADD_LEN(s)      s, MBEDTLS_OID_SIZE(s)
+#define NULL_OID_DESCRIPTOR                   { NULL, 0 }
 
 /*
  * Macro to generate an internal function for oid_XXX_from_asn1() (used by
@@ -372,7 +373,7 @@ static const oid_sig_alg_t oid_sig_alg[] =
     },
 #endif /* MBEDTLS_SHA1_C */
 #endif /* MBEDTLS_RSA_C */
-#if defined(MBEDTLS_ECDSA_C)
+#if defined(MBEDTLS_ECDSA_C) || defined(MBEDTLS_USE_TINYCRYPT)
 #if defined(MBEDTLS_SHA1_C)
     {
         { ADD_LEN( MBEDTLS_OID_ECDSA_SHA1 ),       "ecdsa-with-SHA1",      "ECDSA with SHA1" },
@@ -399,7 +400,7 @@ static const oid_sig_alg_t oid_sig_alg[] =
         MBEDTLS_MD_SHA512,   MBEDTLS_PK_ECDSA,
     },
 #endif /* MBEDTLS_SHA512_C */
-#endif /* MBEDTLS_ECDSA_C */
+#endif /* MBEDTLS_ECDSA_C || MBEDTLS_USE_TINYCRYPT */
 #if defined(MBEDTLS_RSA_C)
     {
         { ADD_LEN( MBEDTLS_OID_RSASSA_PSS ),        "RSASSA-PSS",           "RSASSA-PSS" },
@@ -450,6 +451,12 @@ FN_OID_TYPED_FROM_ASN1(oid_pk_alg_t, pk_alg, oid_pk_alg)
 FN_OID_GET_ATTR1(mbedtls_oid_get_pk_alg, oid_pk_alg_t, pk_alg, mbedtls_pk_type_t, pk_alg)
 FN_OID_GET_OID_BY_ATTR1(mbedtls_oid_get_oid_by_pk_alg, oid_pk_alg_t, oid_pk_alg, mbedtls_pk_type_t, pk_alg)
 
+#if defined(MBEDTLS_USE_TINYCRYPT)
+typedef struct {
+    mbedtls_oid_descriptor_t    descriptor;
+    mbedtls_uecc_group_id       grp_id;
+} oid_ecp_grp_t;
+#else
 #if defined(MBEDTLS_ECP_C)
 /*
  * For namedCurve (RFC 5480)
@@ -458,7 +465,26 @@ typedef struct {
     mbedtls_oid_descriptor_t    descriptor;
     mbedtls_ecp_group_id        grp_id;
 } oid_ecp_grp_t;
+#endif
+#endif
 
+#if defined(MBEDTLS_USE_TINYCRYPT)
+static const oid_ecp_grp_t oid_ecp_grp[] =
+{
+    {
+        { ADD_LEN( MBEDTLS_OID_EC_GRP_SECP256R1 ), "secp256r1", "secp256r1" },
+        MBEDTLS_UECC_DP_SECP256R1,
+    },
+    {
+        NULL_OID_DESCRIPTOR,
+        MBEDTLS_UECC_DP_NONE,
+    },
+};
+FN_OID_TYPED_FROM_ASN1(oid_ecp_grp_t, grp_id, oid_ecp_grp)
+FN_OID_GET_ATTR1(mbedtls_oid_get_ec_grp, oid_ecp_grp_t, grp_id, mbedtls_uecc_group_id, grp_id)
+FN_OID_GET_OID_BY_ATTR1(mbedtls_oid_get_oid_by_ec_grp, oid_ecp_grp_t, oid_ecp_grp, mbedtls_uecc_group_id, grp_id)
+#else
+#if defined(MBEDTLS_ECP_C)
 static const oid_ecp_grp_t oid_ecp_grp[] =
 {
 #if defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED)
@@ -537,6 +563,7 @@ FN_OID_TYPED_FROM_ASN1(oid_ecp_grp_t, grp_id, oid_ecp_grp)
 FN_OID_GET_ATTR1(mbedtls_oid_get_ec_grp, oid_ecp_grp_t, grp_id, mbedtls_ecp_group_id, grp_id)
 FN_OID_GET_OID_BY_ATTR1(mbedtls_oid_get_oid_by_ec_grp, oid_ecp_grp_t, oid_ecp_grp, mbedtls_ecp_group_id, grp_id)
 #endif /* MBEDTLS_ECP_C */
+#endif
 
 #if defined(MBEDTLS_CIPHER_C)
 /*
diff --git a/library/pk.c b/library/pk.c
index ecf002d45..7376b5a1f 100644
--- a/library/pk.c
+++ b/library/pk.c
@@ -35,12 +35,28 @@
 #if defined(MBEDTLS_ECDSA_C)
 #include "mbedtls/ecdsa.h"
 #endif
+#if defined(MBEDTLS_USE_TINYCRYPT)
+#include "tinycrypt/ecc.h"
+#include "tinycrypt/ecc_dsa.h"
+#include "mbedtls/asn1.h"
+#include "mbedtls/asn1write.h"
+#endif /* MBEDTLS_USE_TINYCRYPT */
 
 #if defined(MBEDTLS_USE_PSA_CRYPTO)
 #include "mbedtls/psa_util.h"
 #endif
 
+#include "mbedtls/platform_util.h"
+#include "mbedtls/platform.h"
+
+#if !defined(MBEDTLS_PLATFORM_C)
+#include <stdlib.h>
+#define mbedtls_calloc    calloc
+#define mbedtls_free       free
+#endif
+
 #include <limits.h>
+#include <string.h>
 #include <stdint.h>
 
 /* Parameter validation macros based on platform_util.h */
@@ -49,6 +65,298 @@
 #define PK_VALIDATE( cond )        \
     MBEDTLS_INTERNAL_VALIDATE( cond )
 
+
+/*
+ * Internal wrappers around ECC functions - based on TinyCrypt
+ */
+#if defined(MBEDTLS_USE_TINYCRYPT)
+/*
+ * An ASN.1 encoded signature is a sequence of two ASN.1 integers. Parse one of
+ * those integers and convert it to the fixed-length encoding.
+ */
+static int extract_ecdsa_sig_int( unsigned char **from, const unsigned char *end,
+                                  unsigned char *to, size_t to_len )
+{
+    int ret;
+    size_t unpadded_len, padding_len;
+
+    if( ( ret = mbedtls_asn1_get_tag( from, end, &unpadded_len,
+                                      MBEDTLS_ASN1_INTEGER ) ) != 0 )
+    {
+        return( ret );
+    }
+
+    while( unpadded_len > 0 && **from == 0x00 )
+    {
+        ( *from )++;
+        unpadded_len--;
+    }
+
+    if( unpadded_len > to_len || unpadded_len == 0 )
+        return( MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
+
+    padding_len = to_len - unpadded_len;
+    memset( to, 0x00, padding_len );
+    mbedtls_platform_memcpy( to + padding_len, *from, unpadded_len );
+    ( *from ) += unpadded_len;
+
+    return( 0 );
+}
+
+/*
+ * Convert a signature from an ASN.1 sequence of two integers
+ * to a raw {r,s} buffer. Note: the provided sig buffer must be at least
+ * twice as big as int_size.
+ */
+static int extract_ecdsa_sig( unsigned char **p, const unsigned char *end,
+                              unsigned char *sig, size_t int_size )
+{
+    int ret;
+    size_t tmp_size;
+
+    if( ( ret = mbedtls_asn1_get_tag( p, end, &tmp_size,
+                MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
+        return( ret );
+
+    /* Extract r */
+    if( ( ret = extract_ecdsa_sig_int( p, end, sig, int_size ) ) != 0 )
+        return( ret );
+    /* Extract s */
+    if( ( ret = extract_ecdsa_sig_int( p, end, sig + int_size, int_size ) ) != 0 )
+        return( ret );
+
+    return( 0 );
+}
+
+static size_t uecc_eckey_get_bitlen( const void *ctx )
+{
+    (void) ctx;
+    return( (size_t) ( NUM_ECC_BYTES * 8 ) );
+}
+
+/* This function compares public keys of two keypairs */
+static int uecc_eckey_check_pair( const void *pub, const void *prv )
+{
+    const mbedtls_uecc_keypair *uecc_pub =
+        (const mbedtls_uecc_keypair *) pub;
+    const mbedtls_uecc_keypair *uecc_prv =
+        (const mbedtls_uecc_keypair *) prv;
+
+    if( mbedtls_platform_memequal( uecc_pub->public_key,
+                uecc_prv->public_key,
+                2 * NUM_ECC_BYTES ) == 0 )
+    {
+        return( 0 );
+    }
+
+    return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
+}
+
+static int uecc_eckey_can_do( mbedtls_pk_type_t type )
+{
+    return( type == MBEDTLS_PK_ECDSA ||
+            type == MBEDTLS_PK_ECKEY );
+}
+
+static int uecc_eckey_verify_wrap( void *ctx, mbedtls_md_type_t md_alg,
+                       const unsigned char *hash, size_t hash_len,
+                       const unsigned char *sig, size_t sig_len )
+{
+    int ret = MBEDTLS_ERR_PLATFORM_FAULT_DETECTED;
+    volatile int ret_fi = UECC_FAULT_DETECTED;
+    uint8_t signature[2*NUM_ECC_BYTES];
+    unsigned char *p;
+    const mbedtls_uecc_keypair *keypair = (const mbedtls_uecc_keypair *) ctx;
+
+    ((void) md_alg);
+    p = (unsigned char*) sig;
+
+    ret = extract_ecdsa_sig( &p, sig + sig_len, signature, NUM_ECC_BYTES );
+    if( ret != 0 )
+        return( ret );
+
+    ret_fi = uECC_verify( keypair->public_key, hash,
+                          (unsigned) hash_len, signature );
+
+    if( ret_fi == UECC_FAULT_DETECTED )
+        return( MBEDTLS_ERR_PLATFORM_FAULT_DETECTED );
+
+    if( ret_fi == UECC_SUCCESS )
+    {
+        mbedtls_platform_random_delay();
+        if( ret_fi == UECC_SUCCESS )
+            return( 0 );
+        else
+            return( MBEDTLS_ERR_PLATFORM_FAULT_DETECTED );
+    }
+
+    return( MBEDTLS_ERR_PK_HW_ACCEL_FAILED );
+}
+
+/*
+ * Simultaneously convert and move raw MPI from the beginning of a buffer
+ * to an ASN.1 MPI at the end of the buffer.
+ * See also mbedtls_asn1_write_mpi().
+ *
+ * p: pointer to the end of the output buffer
+ * start: start of the output buffer, and also of the mpi to write at the end
+ * n_len: length of the mpi to read from start
+ *
+ * Warning:
+ * The total length of the output buffer must be smaller than 128 Bytes.
+ */
+static int asn1_write_mpibuf( unsigned char **p, unsigned char *start,
+                              size_t n_len )
+{
+    size_t len = n_len;
+    int ret = MBEDTLS_ERR_PLATFORM_FAULT_DETECTED;
+
+    if( (size_t)( *p - start ) < len )
+        return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );
+
+    *p -= len;
+    ret = mbedtls_platform_memmove( *p, start, len );
+    if( ret != 0 )
+    {
+        return( ret );
+    }
+
+    /* ASN.1 DER encoding requires minimal length, so skip leading 0s.
+     * Neither r nor s should be 0, but as a failsafe measure, still detect
+     * that rather than overflowing the buffer in case of an error. */
+    while( len > 0 && **p == 0x00 )
+    {
+        ++(*p);
+        --len;
+    }
+
+    /* this is only reached if the signature was invalid */
+    if( len == 0 )
+        return( MBEDTLS_ERR_PK_HW_ACCEL_FAILED );
+
+    /* if the msb is 1, ASN.1 requires that we prepend a 0.
+     * Neither r nor s can be 0, so we can assume len > 0 at all times. */
+    if( **p & 0x80 )
+    {
+        if( *p - start < 1 )
+            return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );
+
+        *--(*p) = 0x00;
+        len += 1;
+    }
+
+    /* Ensure that there is still space for len and ASN1_INTEGER */
+    if( ( *p - start ) < 2 )
+        return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );
+
+    /* The ASN.1 length encoding is just a single Byte containing the length,
+     * as we assume that the total buffer length is smaller than 128 Bytes. */
+    *--(*p) = len;
+    *--(*p) = MBEDTLS_ASN1_INTEGER;
+    len += 2;
+
+    return( (int) len );
+}
+
+/* Transcode signature from uECC format to ASN.1 sequence.
+ * See ecdsa_signature_to_asn1 in ecdsa.c, but with byte buffers instead of
+ * MPIs, and in-place.
+ *
+ * [in/out] sig: the signature pre- and post-transcoding
+ * [in/out] sig_len: signature length pre- and post-transcoding
+ * [in] buf_len: the available size the in/out buffer
+ *
+ * Warning: buf_len must be smaller than 128 Bytes.
+ */
+static int pk_ecdsa_sig_asn1_from_uecc( unsigned char *sig, size_t *sig_len,
+                                        size_t buf_len )
+{
+    int ret = MBEDTLS_ERR_PLATFORM_FAULT_DETECTED;
+    size_t len = 0;
+    const size_t rs_len = *sig_len / 2;
+    unsigned char *p = sig + buf_len;
+
+    MBEDTLS_ASN1_CHK_ADD( len, asn1_write_mpibuf( &p, sig + rs_len, rs_len ) );
+    MBEDTLS_ASN1_CHK_ADD( len, asn1_write_mpibuf( &p, sig, rs_len ) );
+
+    if( p - sig < 2 )
+        return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );
+
+    /* The ASN.1 length encoding is just a single Byte containing the length,
+     * as we assume that the total buffer length is smaller than 128 Bytes. */
+    *--p = len;
+    *--p = MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE;
+    len += 2;
+
+    ret = mbedtls_platform_memmove( sig, p, len );
+    if( ret != 0 )
+    {
+        return( ret );
+    }
+    *sig_len = len;
+
+    return( ret );
+}
+
+static int uecc_eckey_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
+                   const unsigned char *hash, size_t hash_len,
+                   unsigned char *sig, size_t *sig_len,
+                   int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
+{
+    const mbedtls_uecc_keypair *keypair = (const mbedtls_uecc_keypair *) ctx;
+    int ret;
+
+    /*
+     * RFC-4492 page 20:
+     *
+     *     Ecdsa-Sig-Value ::= SEQUENCE {
+     *         r       INTEGER,
+     *         s       INTEGER
+     *     }
+     *
+     * Size is at most
+     *    1 (tag) + 1 (len) + 1 (initial 0) + NUM_ECC_BYTES for each of r and s,
+     *    twice that + 1 (tag) + 2 (len) for the sequence
+     *
+     * (The ASN.1 length encodings are all 1-Byte encodings because
+     *  the total size is smaller than 128 Bytes).
+     */
+     #define MAX_SECP256R1_ECDSA_SIG_LEN ( 3 + 2 * ( 3 + NUM_ECC_BYTES ) )
+
+    ret = uECC_sign( keypair->private_key, hash, hash_len, sig );
+    if( ret == UECC_FAULT_DETECTED )
+        return( MBEDTLS_ERR_PLATFORM_FAULT_DETECTED );
+    if( ret != UECC_SUCCESS )
+        return( MBEDTLS_ERR_PK_HW_ACCEL_FAILED );
+
+    *sig_len = 2 * NUM_ECC_BYTES;
+
+    /* uECC owns its rng function pointer */
+    (void) f_rng;
+    (void) p_rng;
+    (void) md_alg;
+
+    return( pk_ecdsa_sig_asn1_from_uecc( sig, sig_len,
+                                         MAX_SECP256R1_ECDSA_SIG_LEN ) );
+
+    #undef MAX_SECP256R1_ECDSA_SIG_LEN
+}
+static void *uecc_eckey_alloc_wrap( void )
+{
+    return( mbedtls_calloc( 1, sizeof( mbedtls_uecc_keypair ) ) );
+}
+
+static void uecc_eckey_free_wrap( void *ctx )
+{
+    if( ctx == NULL )
+        return;
+
+    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_uecc_keypair ) );
+    mbedtls_free( ctx );
+}
+const mbedtls_pk_info_t mbedtls_uecc_eckey_info =
+                        MBEDTLS_PK_INFO( MBEDTLS_PK_INFO_ECKEY );
+#endif /* MBEDTLS_USE_TINYCRYPT */
 /*
  * Initialise a mbedtls_pk_context
  */
@@ -114,8 +422,6 @@ const mbedtls_pk_info_t * mbedtls_pk_info_from_type( mbedtls_pk_type_t pk_type )
             return( &mbedtls_rsa_info );
 #endif
 #if defined(MBEDTLS_ECP_C)
-        case MBEDTLS_PK_ECKEY:
-            return( &mbedtls_eckey_info );
         case MBEDTLS_PK_ECKEY_DH:
             return( &mbedtls_eckeydh_info );
 #endif
@@ -123,6 +429,15 @@ const mbedtls_pk_info_t * mbedtls_pk_info_from_type( mbedtls_pk_type_t pk_type )
         case MBEDTLS_PK_ECDSA:
             return( &mbedtls_ecdsa_info );
 #endif
+#if defined(MBEDTLS_USE_TINYCRYPT)
+        case MBEDTLS_PK_ECKEY:
+            return( &mbedtls_uecc_eckey_info );
+#else /* MBEDTLS_USE_TINYCRYPT */
+#if defined(MBEDTLS_ECP_C)
+        case MBEDTLS_PK_ECKEY:
+            return( &mbedtls_eckey_info );
+#endif
+#endif /* MBEDTLS_USE_TINYCRYPT */
         /* MBEDTLS_PK_RSA_ALT omitted on purpose */
         default:
             return( NULL );
diff --git a/library/pkparse.c b/library/pkparse.c
index 0590f2b05..bf03f7542 100644
--- a/library/pkparse.c
+++ b/library/pkparse.c
@@ -47,6 +47,9 @@
 #if defined(MBEDTLS_PKCS12_C)
 #include "mbedtls/pkcs12.h"
 #endif
+#if defined(MBEDTLS_USE_TINYCRYPT)
+#include "tinycrypt/ecc.h"
+#endif
 
 #if defined(MBEDTLS_PLATFORM_C)
 #include "mbedtls/platform.h"
@@ -171,7 +174,28 @@ int mbedtls_pk_parse_public_keyfile( mbedtls_pk_context *ctx, const char *path )
 }
 #endif /* MBEDTLS_FS_IO */
 
-#if defined(MBEDTLS_ECP_C)
+#if defined(MBEDTLS_USE_TINYCRYPT)
+static int pk_use_ecparams( const mbedtls_asn1_buf *params )
+{
+    mbedtls_uecc_group_id grp_id;
+
+    if( params->tag == MBEDTLS_ASN1_OID )
+    {
+        if( mbedtls_oid_get_ec_grp( params, &grp_id ) != 0 )
+            return( MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE );
+    }
+    else
+    {
+        // Only P-256 is supported
+        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
+    }
+
+    return( 0 );
+}
+#endif /* MBEDTLS_USE_TINYCRYPT */
+
+#if defined(MBEDTLS_ECP_C) || \
+    defined(MBEDTLS_USE_TINYCRYPT)
 /* Minimally parse an ECParameters buffer to and mbedtls_asn1_buf
  *
  * ECParameters ::= CHOICE {
@@ -215,7 +239,11 @@ static int pk_get_ecparams( unsigned char **p, const unsigned char *end,
 
     return( 0 );
 }
+#endif /* MBEDTLS_ECP_C || MBEDTLS_USE_TINYCRYPT */
+
+#if !defined(MBEDTLS_USE_TINYCRYPT)
 
+#if defined(MBEDTLS_ECP_C)
 #if defined(MBEDTLS_PK_PARSE_EC_EXTENDED)
 /*
  * Parse a SpecifiedECDomain (SEC 1 C.2) and (mostly) fill the group with it.
@@ -511,6 +539,52 @@ static int pk_get_ecpubkey( unsigned char **p, const unsigned char *end,
     return( ret );
 }
 #endif /* MBEDTLS_ECP_C */
+#endif /* !MBEDTLS_USE_TINYCRYPT */
+
+#if defined(MBEDTLS_USE_TINYCRYPT)
+/*
+ * Import a point from unsigned binary data (SEC1 2.3.4)
+ */
+static int uecc_public_key_read_binary( mbedtls_uecc_keypair *uecc_keypair,
+                                        const unsigned char *buf, size_t ilen )
+{
+    if( ilen != 2 * NUM_ECC_BYTES + 1 )
+        return( MBEDTLS_ERR_PK_INVALID_PUBKEY );
+
+    /* We are not handling the point at infinity. */
+
+    if( buf[0] != 0x04 )
+        return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );
+
+    if( mbedtls_platform_memcpy( uecc_keypair->public_key, buf + 1, 2 * NUM_ECC_BYTES ) ==
+                                 uecc_keypair->public_key )
+    {
+        return( 0 );
+    }
+
+    return( MBEDTLS_ERR_PLATFORM_FAULT_DETECTED );
+}
+
+static int pk_get_ueccpubkey( unsigned char **p,
+                           const unsigned char *end,
+                           uint8_t *pk_context)
+{
+    mbedtls_uecc_keypair *uecc_keypair = (mbedtls_uecc_keypair *) pk_context;
+    int ret;
+
+    if( ( ret = uecc_public_key_read_binary( uecc_keypair,
+                                             (const unsigned char *) *p, end - *p ) )
+            != 0 )
+        return ret;
+
+    /*
+     * We know uecc_public_key_read_binary consumed all bytes or failed
+     */
+    *p = (unsigned char *) end;
+
+    return( ret );
+}
+#endif /* MBEDTLS_USE_TINYCRYPT */
 
 #if defined(MBEDTLS_RSA_C)
 /*
@@ -651,6 +725,12 @@ int mbedtls_pk_parse_subpubkey( unsigned char **p, const unsigned char *end,
         ret = pk_get_rsapubkey( p, end, mbedtls_pk_rsa( *pk ) );
     } else
 #endif /* MBEDTLS_RSA_C */
+#if defined(MBEDTLS_USE_TINYCRYPT)
+    if( pk_alg == MBEDTLS_PK_ECKEY )
+    {
+        ret = pk_get_ueccpubkey( p, end, (uint8_t*) pk->pk_ctx );
+    } else
+#else /* MBEDTLS_USE_TINYCRYPT */
 #if defined(MBEDTLS_ECP_C)
     if( pk_alg == MBEDTLS_PK_ECKEY_DH || pk_alg == MBEDTLS_PK_ECKEY )
     {
@@ -659,6 +739,7 @@ int mbedtls_pk_parse_subpubkey( unsigned char **p, const unsigned char *end,
             ret = pk_get_ecpubkey( p, end, mbedtls_pk_ec( *pk ) );
     } else
 #endif /* MBEDTLS_ECP_C */
+#endif /* MBEDTLS_USE_TINYCRYPT */
         ret = MBEDTLS_ERR_PK_UNKNOWN_PK_ALG;
 
     if( ret == 0 && *p != end )
@@ -854,6 +935,129 @@ cleanup:
 }
 #endif /* MBEDTLS_RSA_C */
 
+#if defined(MBEDTLS_USE_TINYCRYPT)
+static int pk_parse_key_sec1_der( mbedtls_uecc_keypair *keypair,
+                                  const unsigned char *key,
+                                  size_t keylen)
+{
+    int ret;
+    int version, pubkey_done;
+    size_t len;
+    mbedtls_asn1_buf params;
+    unsigned char *p = (unsigned char *) key;
+    unsigned char *end = p + keylen;
+    unsigned char *end2;
+
+    /*
+     * RFC 5915, or SEC1 Appendix C.4
+     *
+     * ECPrivateKey ::= SEQUENCE {
+     *      version        INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
+     *      privateKey     OCTET STRING,
+     *      parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,
+     *      publicKey  [1] BIT STRING OPTIONAL
+     *    }
+     */
+    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
+            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
+    {
+        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
+    }
+
+    end = p + len;
+
+    if( ( ret = mbedtls_asn1_get_int( &p, end, &version ) ) != 0 )
+        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
+
+    if( version != 1 )
+        return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION );
+
+    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
+        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
+
+    if( mbedtls_platform_memcpy( keypair->private_key, p, len ) !=
+                                 keypair->private_key )
+    {
+        return( MBEDTLS_ERR_PLATFORM_FAULT_DETECTED );
+    }
+
+    p += len;
+
+    pubkey_done = 0;
+    if( p != end )
+    {
+        /*
+         * Is 'parameters' present?
+         */
+        if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
+                        MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 0 ) ) == 0 )
+        {
+            if( ( ret = pk_get_ecparams( &p, p + len, &params) ) != 0 ||
+                ( ret = pk_use_ecparams( &params )  ) != 0 )
+            {
+                return( ret );
+            }
+        }
+        else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
+        {
+            return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
+        }
+    }
+
+    if( p != end )
+    {
+        /*
+         * Is 'publickey' present? If not, or if we can't read it (eg because it
+         * is compressed), create it from the private key.
+         */
+        if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
+                        MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 1 ) ) == 0 )
+        {
+            end2 = p + len;
+
+            if( ( ret = mbedtls_asn1_get_bitstring_null( &p, end2, &len ) ) != 0 )
+                return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
+
+            if( p + len != end2 )
+                return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
+                        MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
+
+            if( ( ret = uecc_public_key_read_binary( keypair,
+                            (const unsigned char *) p, end2 - p ) ) == 0 )
+            {
+                pubkey_done = 1;
+            }
+            else
+            {
+                /*
+                 * The only acceptable failure mode of
+                 * uecc_public_key_read_binary() above
+                 * is if the point format is not recognized.
+                 */
+                if( ret != MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE )
+                    return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
+            }
+        }
+        else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
+        {
+            return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
+        }
+    }
+
+    if( !pubkey_done )
+    {
+        ret = uECC_compute_public_key( keypair->private_key,
+                                       keypair->public_key );
+        if( ret == UECC_FAULT_DETECTED )
+            return( MBEDTLS_ERR_PLATFORM_FAULT_DETECTED );
+        if( ret != UECC_SUCCESS )
+            return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
+    }
+
+    return( 0 );
+}
+#else /* MBEDTLS_USE_TINYCRYPT */
+
 #if defined(MBEDTLS_ECP_C)
 /*
  * Parse a SEC1 encoded private EC key
@@ -982,6 +1186,7 @@ static int pk_parse_key_sec1_der( mbedtls_ecp_keypair *eck,
     return( 0 );
 }
 #endif /* MBEDTLS_ECP_C */
+#endif /* MBEDTLS_USE_TINYCRYPT */
 
 /*
  * Parse an unencrypted PKCS#8 encoded private key
@@ -1065,6 +1270,16 @@ static int pk_parse_key_pkcs8_unencrypted_der(
         }
     } else
 #endif /* MBEDTLS_RSA_C */
+#if defined(MBEDTLS_USE_TINYCRYPT)
+    if( pk_alg == MBEDTLS_PK_ECKEY )
+    {
+        if( ( ret = pk_use_ecparams( &params ) ) != 0 ||
+            ( ret = pk_parse_key_sec1_der( mbedtls_pk_uecc( *pk ), p, len ) ) != 0)
+        {
+            return( ret );
+        }
+    } else
+#else /* MBEDTLS_USE_TINYCRYPT */
 #if defined(MBEDTLS_ECP_C)
     if( pk_alg == MBEDTLS_PK_ECKEY || pk_alg == MBEDTLS_PK_ECKEY_DH )
     {
@@ -1076,6 +1291,7 @@ static int pk_parse_key_pkcs8_unencrypted_der(
         }
     } else
 #endif /* MBEDTLS_ECP_C */
+#endif /* MBEDTLS_USE_TINYCRYPT */
         return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
 
     return( 0 );
@@ -1261,7 +1477,7 @@ int mbedtls_pk_parse_key( mbedtls_pk_context *pk,
         return( ret );
 #endif /* MBEDTLS_RSA_C */
 
-#if defined(MBEDTLS_ECP_C)
+#if defined(MBEDTLS_ECP_C) || defined(MBEDTLS_USE_TINYCRYPT)
     /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */
     if( key[keylen - 1] != '\0' )
         ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;
@@ -1274,9 +1490,15 @@ int mbedtls_pk_parse_key( mbedtls_pk_context *pk,
     {
         pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_ECKEY );
 
+#if defined(MBEDTLS_USE_TINYCRYPT)
+        if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 ||
+            ( ret = pk_parse_key_sec1_der( mbedtls_pk_uecc( *pk ),
+                                           pem.buf, pem.buflen ) ) != 0 )
+#else /* MBEDTLS_USE_TINYCRYPT */
         if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 ||
             ( ret = pk_parse_key_sec1_der( mbedtls_pk_ec( *pk ),
                                            pem.buf, pem.buflen ) ) != 0 )
+#endif /* MBEDTLS_USE_TINYCRYPT */
         {
             mbedtls_pk_free( pk );
         }
@@ -1290,7 +1512,7 @@ int mbedtls_pk_parse_key( mbedtls_pk_context *pk,
         return( MBEDTLS_ERR_PK_PASSWORD_REQUIRED );
     else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
         return( ret );
-#endif /* MBEDTLS_ECP_C */
+#endif /* MBEDTLS_ECP_C || MBEDTLS_USE_TINYCRYPT */
 
     /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */
     if( key[keylen - 1] != '\0' )
@@ -1397,6 +1619,15 @@ int mbedtls_pk_parse_key( mbedtls_pk_context *pk,
     mbedtls_pk_init( pk );
 #endif /* MBEDTLS_RSA_C */
 
+#if defined(MBEDTLS_USE_TINYCRYPT)
+    pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_ECKEY );
+    if( mbedtls_pk_setup( pk, pk_info ) == 0 &&
+        pk_parse_key_sec1_der( mbedtls_pk_uecc( *pk),
+                               key, keylen) == 0)
+    {
+        return( 0 );
+    }
+#else /* MBEDTLS_USE_TINYCRYPT */
 #if defined(MBEDTLS_ECP_C)
     pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_ECKEY );
     if( mbedtls_pk_setup( pk, pk_info ) == 0 &&
@@ -1407,6 +1638,7 @@ int mbedtls_pk_parse_key( mbedtls_pk_context *pk,
     }
     mbedtls_pk_free( pk );
 #endif /* MBEDTLS_ECP_C */
+#endif /* MBEDTLS_USE_TINYCRYPT */
 
     /* If MBEDTLS_RSA_C is defined but MBEDTLS_ECP_C isn't,
      * it is ok to leave the PK context initialized but not
diff --git a/library/pkwrite.c b/library/pkwrite.c
index 0da369818..79c7af3d8 100644
--- a/library/pkwrite.c
+++ b/library/pkwrite.c
@@ -104,6 +104,59 @@ end_of_export:
 }
 #endif /* MBEDTLS_RSA_C */
 
+#if defined(MBEDTLS_USE_TINYCRYPT)
+static int pk_write_ec_pubkey( unsigned char **p, unsigned char *start,
+                               mbedtls_pk_context const *key )
+{
+    size_t const len = 1 + 2 * NUM_ECC_BYTES;
+    mbedtls_uecc_keypair const * const uecc = mbedtls_pk_uecc( *key );
+
+    if( *p < start || (size_t)( *p - start ) < len )
+        return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );
+
+    *p -= len;
+    (*p)[0] = 0x04;
+    mbedtls_platform_memcpy( *p + 1, uecc->public_key, 2 * NUM_ECC_BYTES );
+
+    return( (int) len );
+}
+
+/*
+ * privateKey  OCTET STRING -- always of length ceil(log2(n)/8)
+ */
+static int pk_write_ec_privkey( unsigned char **p, unsigned char *start,
+                                mbedtls_pk_context const *key )
+{
+    mbedtls_uecc_keypair const * const uecc = mbedtls_pk_uecc( *key );
+    return( mbedtls_asn1_write_octet_string(
+                p, start,
+                uecc->private_key,
+                NUM_ECC_BYTES ) );
+}
+
+/*
+ * ECParameters ::= CHOICE {
+ *   namedCurve         OBJECT IDENTIFIER
+ * }
+ */
+static int pk_write_ec_param( unsigned char **p, unsigned char *start,
+                              mbedtls_pk_context const *key )
+{
+    int ret;
+    size_t len = 0;
+    const char *oid;
+    size_t oid_len;
+    ((void) key);
+
+    if( ( ret = mbedtls_oid_get_oid_by_ec_grp( MBEDTLS_UECC_DP_SECP256R1,
+                                               &oid, &oid_len ) ) != 0 )
+        return( ret );
+
+    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_oid( p, start, oid, oid_len ) );
+
+    return( (int) len );
+}
+#else /* MBEDTLS_USE_TINYCRYPT */
 #if defined(MBEDTLS_ECP_C)
 /*
  * EC public key is an EC point
@@ -172,6 +225,7 @@ exit:
     return( ret );
 }
 #endif /* MBEDTLS_ECP_C */
+#endif /* MBEDTLS_USE_TINYCRYPT */
 
 int mbedtls_pk_write_pubkey( unsigned char **p, unsigned char *start,
                              const mbedtls_pk_context *key )
@@ -189,9 +243,13 @@ int mbedtls_pk_write_pubkey( unsigned char **p, unsigned char *start,
         MBEDTLS_ASN1_CHK_ADD( len, pk_write_rsa_pubkey( p, start, mbedtls_pk_rsa( *key ) ) );
     else
 #endif
-#if defined(MBEDTLS_ECP_C)
+#if defined(MBEDTLS_ECP_C) || defined(MBEDTLS_USE_TINYCRYPT)
     if( mbedtls_pk_get_type( key ) == MBEDTLS_PK_ECKEY )
-        MBEDTLS_ASN1_CHK_ADD( len, pk_write_ec_pubkey( p, start, mbedtls_pk_ec( *key ) ) );
+#if defined(MBEDTLS_USE_TINYCRYPT)
+        MBEDTLS_ASN1_CHK_ADD( len, pk_write_ec_pubkey( p, start, key ) );
+#else
+    	MBEDTLS_ASN1_CHK_ADD( len, pk_write_ec_pubkey( p, start, mbedtls_pk_ec( *key ) ) );
+#endif
     else
 #endif
 #if defined(MBEDTLS_USE_PSA_CRYPTO)
@@ -254,10 +312,14 @@ int mbedtls_pk_write_pubkey_der( mbedtls_pk_context *key, unsigned char *buf, si
     MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( &c, buf, MBEDTLS_ASN1_BIT_STRING ) );
 
     pk_type = mbedtls_pk_get_type( key );
-#if defined(MBEDTLS_ECP_C)
+#if defined(MBEDTLS_ECP_C) || defined(MBEDTLS_USE_TINYCRYPT)
     if( pk_type == MBEDTLS_PK_ECKEY )
     {
+#if defined(MBEDTLS_USE_TINYCRYPT)
+        MBEDTLS_ASN1_CHK_ADD( par_len, pk_write_ec_param( &c, buf, key ) );
+#else
         MBEDTLS_ASN1_CHK_ADD( par_len, pk_write_ec_param( &c, buf, mbedtls_pk_ec( *key ) ) );
+#endif
     }
 #endif
 #if defined(MBEDTLS_USE_PSA_CRYPTO)
@@ -402,10 +464,9 @@ int mbedtls_pk_write_key_der( mbedtls_pk_context *key, unsigned char *buf, size_
     }
     else
 #endif /* MBEDTLS_RSA_C */
-#if defined(MBEDTLS_ECP_C)
+#if defined(MBEDTLS_ECP_C) || defined(MBEDTLS_USE_TINYCRYPT)
     if( mbedtls_pk_get_type( key ) == MBEDTLS_PK_ECKEY )
     {
-        mbedtls_ecp_keypair *ec = mbedtls_pk_ec( *key );
         size_t pub_len = 0, par_len = 0;
 
         /*
@@ -420,7 +481,11 @@ int mbedtls_pk_write_key_der( mbedtls_pk_context *key, unsigned char *buf, size_
          */
 
         /* publicKey */
-        MBEDTLS_ASN1_CHK_ADD( pub_len, pk_write_ec_pubkey( &c, buf, ec ) );
+#if defined(MBEDTLS_USE_TINYCRYPT)
+        MBEDTLS_ASN1_CHK_ADD( pub_len, pk_write_ec_pubkey( &c, buf, key ) );
+#else
+        MBEDTLS_ASN1_CHK_ADD( pub_len, pk_write_ec_pubkey( &c, buf, mbedtls_pk_ec( *key ) ) );
+#endif
 
         if( c - buf < 1 )
             return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );
@@ -436,7 +501,11 @@ int mbedtls_pk_write_key_der( mbedtls_pk_context *key, unsigned char *buf, size_
         len += pub_len;
 
         /* parameters */
-        MBEDTLS_ASN1_CHK_ADD( par_len, pk_write_ec_param( &c, buf, ec ) );
+#if defined(MBEDTLS_USE_TINYCRYPT)
+        MBEDTLS_ASN1_CHK_ADD( par_len, pk_write_ec_param( &c, buf, key ) );
+#else
+        MBEDTLS_ASN1_CHK_ADD( par_len, pk_write_ec_param( &c, buf, mbedtls_pk_ec( *key ) ) );
+#endif
 
         MBEDTLS_ASN1_CHK_ADD( par_len, mbedtls_asn1_write_len( &c, buf, par_len ) );
         MBEDTLS_ASN1_CHK_ADD( par_len, mbedtls_asn1_write_tag( &c, buf,
@@ -444,7 +513,11 @@ int mbedtls_pk_write_key_der( mbedtls_pk_context *key, unsigned char *buf, size_
         len += par_len;
 
         /* privateKey */
-        MBEDTLS_ASN1_CHK_ADD( len, pk_write_ec_private( &c, buf, ec ) );
+#if defined(MBEDTLS_USE_TINYCRYPT)
+        MBEDTLS_ASN1_CHK_ADD( len, pk_write_ec_privkey( &c, buf, key ) );
+#else
+        MBEDTLS_ASN1_CHK_ADD( len, pk_write_ec_private( &c, buf, mbedtls_pk_ec( *key ) ) );
+#endif
 
         /* version */
         MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_int( &c, buf, 1 ) );
@@ -454,7 +527,7 @@ int mbedtls_pk_write_key_der( mbedtls_pk_context *key, unsigned char *buf, size_
                                                     MBEDTLS_ASN1_SEQUENCE ) );
     }
     else
-#endif /* MBEDTLS_ECP_C */
+#endif /* MBEDTLS_ECP_C || MBEDTLS_USE_TINYCRYPT */
         return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );
 
     return( (int) len );
@@ -543,9 +616,19 @@ int mbedtls_pk_write_key_der( mbedtls_pk_context *key, unsigned char *buf, size_
 
 #else /* MBEDTLS_ECP_C */
 
+#if defined(MBEDTLS_USE_TINYCRYPT)
+
+/* see above, replacing ECP_MAX_BYTES with 32 (256-bit) */
+#define ECP_PUB_DER_MAX_BYTES   30 + 2 * 32
+#define ECP_PRV_DER_MAX_BYTES   29 + 3 * 32
+
+#else /* MBEDTLS_USE_TINYCRYPT */
+
 #define ECP_PUB_DER_MAX_BYTES   0
 #define ECP_PRV_DER_MAX_BYTES   0
 
+#endif /* MBEDTLS_USE_TINYCRYPT */
+
 #endif /* MBEDTLS_ECP_C */
 
 #define PUB_DER_MAX_BYTES   RSA_PUB_DER_MAX_BYTES > ECP_PUB_DER_MAX_BYTES ? \
@@ -598,15 +681,15 @@ int mbedtls_pk_write_key_pem( mbedtls_pk_context *key, unsigned char *buf, size_
         end = PEM_END_PRIVATE_KEY_RSA;
     }
     else
-#endif
-#if defined(MBEDTLS_ECP_C)
+#endif /* MBEDTLS_RSA_C */
+#if defined(MBEDTLS_ECP_C) || defined(MBEDTLS_USE_TINYCRYPT)
     if( mbedtls_pk_get_type( key ) == MBEDTLS_PK_ECKEY )
     {
         begin = PEM_BEGIN_PRIVATE_KEY_EC;
         end = PEM_END_PRIVATE_KEY_EC;
     }
     else
-#endif
+#endif /* MBEDTLS_ECP_C || MBEDTLS_USE_TINYCRYPT */
         return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );
 
     if( ( ret = mbedtls_pem_write_buffer( begin, end,
diff --git a/library/platform_util.c b/library/platform_util.c
index 98fe5deb2..ef5fde8b9 100644
--- a/library/platform_util.c
+++ b/library/platform_util.c
@@ -32,9 +32,39 @@
 #include "mbedtls/platform.h"
 #include "mbedtls/threading.h"
 
+//#if !defined(MBEDTLS_PLATFORM_C)
+//#include <stdlib.h>
+//#define mbedtls_calloc    calloc
+//#define mbedtls_free       free
+//#endif
+
+#if defined(MBEDTLS_ENTROPY_HARDWARE_ALT)
+#include "mbedtls/entropy_poll.h"
+#endif
+
+#if defined(MBEDTLS_PLATFORM_FAULT_CALLBACKS)
+#include "platform_fault.h"
+#else
+static void mbedtls_platform_fault(){}
+#endif
+
 #include <stddef.h>
 #include <string.h>
 
+/* Max number of loops for mbedtls_platform_random_delay. */
+#define MAX_RAND_DELAY  100
+
+/* Parameters for the linear congruential generator used as a non-cryptographic
+ * random number generator. The same parameters are used by e.g. ANSI C. */
+#define RAND_MULTIPLIER 1103515245
+#define RAND_INCREMENT  12345
+#define RAND_MODULUS    0x80000000
+
+/* The number of iterations after which the seed of the non-cryptographic
+ * random number generator will be changed. This is used only if the
+ * MBEDTLS_ENTROPY_HARDWARE_ALT option is enabled. */
+#define RAND_SEED_LIFE  10000
+
 #if !defined(MBEDTLS_PLATFORM_ZEROIZE_ALT)
 /*
  * This implementation should never be optimized out by the compiler
@@ -62,6 +92,34 @@
  * mbedtls_platform_zeroize() to use a suitable implementation for their
  * platform and needs.
  */
+#if defined(MBEDTLS_USE_TINYCRYPT)
+
+void *mbedtls_platform_memset( void *, int, size_t );
+static void * (* const volatile memset_func)( void *, int, size_t ) = mbedtls_platform_memset;
+
+void *mbedtls_platform_zeroize( void *buf, size_t len )
+{
+    volatile size_t vlen = len;
+
+    MBEDTLS_INTERNAL_VALIDATE_RET( ( len == 0 || buf != NULL ), NULL );
+
+    if( vlen > 0 )
+    {
+        return memset_func( buf, 0, vlen );
+    }
+    else
+    {
+        mbedtls_platform_random_delay();
+        if( vlen == 0 && vlen == len )
+        {
+            return buf;
+        }
+    }
+    return NULL;
+}
+
+#else
+
 static void * (* const volatile memset_func)( void *, int, size_t ) = memset;
 
 void mbedtls_platform_zeroize( void *buf, size_t len )
@@ -71,8 +129,284 @@ void mbedtls_platform_zeroize( void *buf, size_t len )
     if( len > 0 )
         memset_func( buf, 0, len );
 }
+
+#endif /* MBEDTLS_USE_TINYCRYPT */
+
 #endif /* MBEDTLS_PLATFORM_ZEROIZE_ALT */
 
+#if defined(MBEDTLS_USE_TINYCRYPT)
+
+void *mbedtls_platform_memset( void *ptr, int value, size_t num )
+{
+    size_t i, start_offset = 0;
+    volatile size_t flow_counter = 0;
+    volatile char *b = ptr;
+    char rnd_data;
+    if( num > 0 )
+    {
+        start_offset = (size_t) mbedtls_platform_random_in_range( (uint32_t) num );
+
+        rnd_data = (char) mbedtls_platform_random_in_range( 256 );
+
+        /* Perform a memset operations with random data and start from a random
+         * location */
+        for( i = start_offset; i < num; ++i )
+        {
+            b[i] = rnd_data;
+            flow_counter++;
+        }
+
+        /* Start from a random location with target data */
+        for( i = start_offset; i < num; ++i )
+        {
+            b[i] = value;
+            flow_counter++;
+        }
+
+        /* Second memset operation with random data */
+        for( i = 0; i < start_offset; ++i )
+        {
+            b[i] = rnd_data;
+            flow_counter++;
+        }
+
+        /* Finish memset operation with correct data */
+        for( i = 0; i < start_offset; ++i )
+        {
+            b[i] = value;
+            flow_counter++;
+        }
+    }
+    /* check the correct number of iterations */
+    if( flow_counter == 2 * num )
+    {
+        mbedtls_platform_random_delay();
+        if( flow_counter == 2 * num )
+        {
+            return ptr;
+        }
+    }
+    mbedtls_platform_fault();
+    return NULL;
+}
+
+void *mbedtls_platform_memcpy( void *dst, const void *src, size_t num )
+{
+    size_t i;
+    volatile size_t flow_counter = 0;
+
+    if( num > 0 )
+    {
+        /* Randomize start offset. */
+        size_t start_offset = (size_t) mbedtls_platform_random_in_range( (uint32_t) num );
+        /* Randomize initial data to prevent leakage while copying */
+        uint32_t data = mbedtls_platform_random_in_range( 256 );
+
+        /* Use memset with random value at first to increase security - memset is
+        not normally part of the memcpy function and here can be useed
+        with regular, unsecured implementation */
+        memset( (void *) dst, data, num );
+
+        /* Make a copy starting from a random location. */
+        i = start_offset;
+        do
+        {
+            ( (char*) dst )[i] = ( (char*) src )[i];
+            flow_counter++;
+        }
+        while( ( i = ( i + 1 ) % num ) != start_offset );
+    }
+
+    /* check the correct number of iterations */
+    if( flow_counter == num )
+    {
+        mbedtls_platform_random_delay();
+        if( flow_counter == num )
+        {
+            return dst;
+        }
+    }
+    mbedtls_platform_fault();
+    return NULL;
+}
+
+int mbedtls_platform_memmove( void *dst, const void *src, size_t num )
+{
+    void *ret1 = NULL;
+    void *ret2 = NULL;
+    /* The buffers can have a common part, so we cannot do a copy from a random
+     * location. By using a temporary buffer we can do so, but the cost of it
+     * is using more memory and longer transfer time. */
+    void *tmp = mbedtls_calloc( 1, num );
+    if( tmp != NULL )
+    {
+        ret1 = mbedtls_platform_memcpy( tmp, src, num );
+        ret2 = mbedtls_platform_memcpy( dst, tmp, num );
+        mbedtls_free( tmp );
+        if( ret1 == tmp && ret2 == dst )
+        {
+            return 0;
+        }
+        return MBEDTLS_ERR_PLATFORM_FAULT_DETECTED;
+    }
+
+    return MBEDTLS_ERR_PLATFORM_ALLOC_FAILED;
+}
+
+#if !defined(MBEDTLS_DEPRECATED_REMOVED)
+int mbedtls_platform_memcmp( const void *buf1, const void *buf2, size_t num )
+{
+    return( mbedtls_platform_memequal( buf1, buf2, num ) );
+}
+#endif /* MBEDTLS_DEPRECATED_REMOVED */
+
+int mbedtls_platform_memequal( const void *buf1, const void *buf2, size_t num )
+{
+    volatile const unsigned char *A = (volatile const unsigned char *) buf1;
+    volatile const unsigned char *B = (volatile const unsigned char *) buf2;
+    volatile unsigned char diff = 0;
+
+    /* Start from a random location and check the correct number of iterations */
+    size_t i, flow_counter = 0;
+    size_t start_offset = 0;
+    if( num > 0 )
+    {
+        start_offset = (size_t) mbedtls_platform_random_in_range( (uint32_t) num );
+
+        for( i = start_offset; i < num; i++ )
+        {
+            unsigned char x = A[i], y = B[i];
+            flow_counter++;
+            diff |= x ^ y;
+        }
+
+        for( i = 0; i < start_offset; i++ )
+        {
+            unsigned char x = A[i], y = B[i];
+            flow_counter++;
+            diff |= x ^ y;
+        }
+    }
+    /* Return 0 only when diff is 0 and flow_counter is equal to num */
+    return( (int) diff | (int) ( flow_counter ^ num ) );
+}
+
+/* This function implements a non-cryptographic random number generator based
+ * on the linear congruential generator algorithm. Additionally, if the
+ * MBEDTLS_ENTROPY_HARDWARE_ALT flag is defined, the seed is set at the first
+ * call of this function with using a hardware random number generator and
+ * changed every RAND_SEED_LIFE number of iterations.
+ *
+ * The value of the returned number is in the range [0; 0xffff].
+ *
+ * Note: The range of values with a 16-bit precision is related to the modulo
+ * parameter of the generator and the fact that the function does not return the
+ * full value of the internal state of the generator.
+ */
+static uint32_t mbedtls_platform_random_uint16( void )
+{
+    /* Set random_state - the first random value should not be zero. */
+    static uint32_t random_state = RAND_INCREMENT;
+
+#if defined(MBEDTLS_ENTROPY_HARDWARE_ALT)
+
+    static uint32_t random_seed_life = 0;
+
+    if( 0 < random_seed_life )
+    {
+        --random_seed_life;
+    }
+    else
+    {
+        size_t olen = 0;
+        uint32_t hw_random;
+        mbedtls_hardware_poll( NULL,
+                               (unsigned char *) &hw_random, sizeof( hw_random ),
+                               &olen );
+        if( olen == sizeof( hw_random ) )
+        {
+            random_state ^= hw_random;
+            random_seed_life = RAND_SEED_LIFE;
+        }
+    }
+
+#endif /* MBEDTLS_ENTROPY_HARDWARE_ALT */
+
+    random_state = ( ( random_state * RAND_MULTIPLIER ) + RAND_INCREMENT ) % RAND_MODULUS;
+
+    /* Do not return the entire random_state to hide generator predictability for
+     * the next iteration */
+    return( ( random_state >> 15 ) & 0xffff );
+}
+
+uint32_t mbedtls_platform_random_uint32( void )
+{
+    return( ( mbedtls_platform_random_uint16() << 16 ) |
+              mbedtls_platform_random_uint16() );
+}
+
+void mbedtls_platform_random_buf( uint8_t *buf, size_t len )
+{
+    volatile size_t flow_control = 0, flow_control_check = len;
+    uint16_t val;
+
+    while( len > 1 )
+    {
+        val = mbedtls_platform_random_uint16();
+        buf[len-1] = (uint8_t)val;
+        buf[len-2] = (uint8_t)(val>>8);
+        len -= 2;
+        flow_control += 2;
+    }
+    if( len == 1 )
+    {
+        buf[0] = (uint8_t)mbedtls_platform_random_uint16();
+        flow_control ++;
+    }
+
+    if ( flow_control == flow_control_check )
+    {
+        return;
+    }
+    mbedtls_platform_fault();
+}
+
+uint32_t mbedtls_platform_random_in_range( uint32_t num )
+{
+    return mbedtls_platform_random_uint32() % num;
+}
+
+void mbedtls_platform_random_delay( void )
+{
+#if defined(MBEDTLS_FI_COUNTERMEASURES)
+    uint32_t rn_1, rn_2, rn_3;
+    volatile size_t i = 0;
+    uint8_t shift;
+
+    rn_1 = mbedtls_platform_random_in_range( MAX_RAND_DELAY );
+    rn_2 = mbedtls_platform_random_in_range( 0xffffffff ) + 1;
+    rn_3 = mbedtls_platform_random_in_range( 0xffffffff ) + 1;
+
+    do
+    {
+        i++;
+        /* Dummy calculations to increase the time between iterations and
+         * make side channel attack more difficult by reducing predictability
+         * of its behaviour. */
+        shift = ( rn_2 & 0x07 ) + 1;
+        if ( i % 2 )
+            rn_2 = ( rn_2 >> shift ) | ( rn_2 << ( 32 - shift ) );
+        else
+            rn_3 = ( rn_3 << shift ) | ( rn_3 >> ( 32 - shift ) );
+        rn_2 ^= rn_3;
+    } while( i < rn_1 || rn_2 == 0 || rn_3 == 0 );
+
+#endif /* MBEDTLS_FI_COUNTERMEASURES */
+    return;
+}
+
+#endif /* MBEDTLS_USE_TINYCRYPT */
+
 #if defined(MBEDTLS_HAVE_TIME_DATE) && !defined(MBEDTLS_PLATFORM_GMTIME_R_ALT)
 #include <time.h>
 #if !defined(_WIN32) && (defined(unix) || \
diff --git a/library/x509_crt.c b/library/x509_crt.c
index a623c57a6..8ec308bb5 100644
--- a/library/x509_crt.c
+++ b/library/x509_crt.c
@@ -120,7 +120,9 @@ const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_next =
     MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA384 ) |
     MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA512 ),
     0xFFFFFFF, /* Any PK alg    */
-#if defined(MBEDTLS_ECP_C)
+#if defined(MBEDTLS_USE_TINYCRYPT)
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_UECC_DP_SECP256R1 ),
+#elif defined(MBEDTLS_ECP_C)
     /* Curves at or above 128-bit security level */
     MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP256R1 ) |
     MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP384R1 ) |
@@ -146,7 +148,9 @@ const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_suiteb =
     /* Only ECDSA */
     MBEDTLS_X509_ID_FLAG( MBEDTLS_PK_ECDSA ) |
     MBEDTLS_X509_ID_FLAG( MBEDTLS_PK_ECKEY ),
-#if defined(MBEDTLS_ECP_C)
+#if defined(MBEDTLS_USE_TINYCRYPT)
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_UECC_DP_SECP256R1 ),
+#elif defined(MBEDTLS_ECP_C)
     /* Only NIST P-256 and P-384 */
     MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP256R1 ) |
     MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP384R1 ),
@@ -207,6 +211,16 @@ static int x509_profile_check_key( const mbedtls_x509_crt_profile *profile,
     }
 #endif
 
+#if defined(MBEDTLS_USE_TINYCRYPT)
+    if( pk_alg == MBEDTLS_PK_ECKEY )
+    {
+        if( ( profile->allowed_curves & MBEDTLS_UECC_DP_SECP256R1 ) != 0 )
+            return( 0 );
+
+        return( -1 );
+    }
+#endif /* MBEDTLS_USE_TINYCRYPT */
+
 #if defined(MBEDTLS_ECP_C)
     if( pk_alg == MBEDTLS_PK_ECDSA ||
         pk_alg == MBEDTLS_PK_ECKEY ||
diff --git a/tinycrypt/CMakeLists.txt b/tinycrypt/CMakeLists.txt
new file mode 100755
index 000000000..7674d83be
--- /dev/null
+++ b/tinycrypt/CMakeLists.txt
@@ -0,0 +1,7 @@
+set(src_tinycrypt
+    ecc_dh.c
+    ecc_dsa.c
+    ecc.c
+)
+
+add_library(tinycrypt STATIC ${src_tinycrypt})
diff --git a/tinycrypt/LICENSE b/tinycrypt/LICENSE
new file mode 100755
index 000000000..2e1db516a
--- /dev/null
+++ b/tinycrypt/LICENSE
@@ -0,0 +1,61 @@
+
+================================================================================
+
+                     TinyCrypt Cryptographic Library                       
+
+================================================================================
+
+          Copyright (c) 2017, Intel Corporation. All rights reserved.         
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  - Redistributions of source code must retain the above copyright notice, this 
+      list of conditions and the following disclaimer.
+      
+  - Redistributions in binary form must reproduce the above copyright notice, 
+      this list of conditions and the following disclaimer in the documentation 
+      and/or other materials provided with the distribution.
+      
+  - Neither the name of the Intel Corporation nor the names of its contributors 
+      may be used to endorse or promote products derived from this software 
+      without specific prior written permission. 
+
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+================================================================================
+Copyright (c) 2014, Kenneth MacKay
+All rights reserved.
+
+https://github.com/kmackay/micro-ecc
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+ * Redistributions of source code must retain the above copyright notice, this
+   list of conditions and the following disclaimer.
+ * Redistributions in binary form must reproduce the above copyright notice,
+   this list of conditions and the following disclaimer in the documentation
+   and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+================================================================================
diff --git a/tinycrypt/README b/tinycrypt/README
new file mode 100755
index 000000000..d0f49a69e
--- /dev/null
+++ b/tinycrypt/README
@@ -0,0 +1,77 @@
+
+================================================================================
+
+                     TinyCrypt Cryptographic Library
+                    (integrated as  part of Mbed TLS)
+
+================================================================================
+
+          Copyright (c) 2017, Intel Corporation. All rights reserved.         
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  - Redistributions of source code must retain the above copyright notice, this 
+      list of conditions and the following disclaimer.
+      
+  - Redistributions in binary form must reproduce the above copyright notice, 
+      this list of conditions and the following disclaimer in the documentation 
+      and/or other materials provided with the distribution.
+      
+  - Neither the name of the Intel Corporation nor the names of its contributors 
+      may be used to endorse or promote products derived from this software 
+      without specific prior written permission. 
+
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+================================================================================
+
+Copyright (c) 2019 ARM Limited
+
+================================================================================
+Overview:
+
+The TinyCrypt Library provides an implementation for constrained devices of a 
+minimal set of standard cryptography primitives. 
+
+This is a modified form of the library based on version 0.2.8 included as part
+of Mbed TLS as a compilation option. It is not included in its full form and
+those wishing to use TinyCrypt should use the original unmodified project.
+
+The original project can be found here: https://github.com/intel/tinycrypt
+
+Contributions should be made upstream to that project, and full documentation 
+can be found in the originating repository.
+
+================================================================================
+
+Organization:
+
+tinycrypt: C source code of the cryptographic primitives.
+include/tinycrypt: C header files of the cryptographic primitives.
+
+No documentation is provided, and instead is available with the original
+project.
+
+Tests are provided as part of Mbed TLS and the Mbed TLS test suites.
+
+================================================================================
+
+Building:
+
+To include TinyCrypt as part of Mbed TLS, enable the configuration option
+MBEDTLS_USE_TINYCRYPT in the configration file 'include/mbedtls/config.h', and
+build as Mbed TLS as normal.
+
+================================================================================
+
diff --git a/tinycrypt/ecc.c b/tinycrypt/ecc.c
new file mode 100755
index 000000000..1a1643836
--- /dev/null
+++ b/tinycrypt/ecc.c
@@ -0,0 +1,1875 @@
+/* ecc.c - TinyCrypt implementation of common ECC functions */
+
+/*
+ *  Copyright (c) 2019, Arm Limited (or its affiliates), All Rights Reserved.
+ *  SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*
+ * Copyright (c) 2014, Kenneth MacKay
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Copyright (C) 2017 by Intel Corporation, All Rights Reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *	- Redistributions of source code must retain the above copyright notice,
+ *	 this list of conditions and the following disclaimer.
+ *
+ *	- Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ *
+ *	- Neither the name of Intel Corporation nor the names of its contributors
+ *	may be used to endorse or promote products derived from this software
+ *	without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#if !defined(MBEDTLS_CONFIG_FILE)
+#include "mbedtls/config.h"
+#else
+#include MBEDTLS_CONFIG_FILE
+#endif
+
+#if defined(MBEDTLS_USE_TINYCRYPT)
+#include <tinycrypt/ecc.h>
+#include "mbedtls/platform_util.h"
+#include "mbedtls/sha256.h"
+#include <string.h>
+#include "mbedtls/platform_util.h"
+
+#if defined(MBEDTLS_PLATFORM_FAULT_CALLBACKS)
+#include "platform_fault.h"
+#else
+static void mbedtls_platform_fault(){}
+#endif
+
+#if defined MBEDTLS_OPTIMIZE_TINYCRYPT_ASM
+#ifndef asm
+#define asm __asm
+#endif
+#endif /* MBEDTLS_OPTIMIZE_TINYCRYPT_ASM */
+
+/* Parameters for curve NIST P-256 aka secp256r1 */
+const uECC_word_t curve_p[NUM_ECC_WORDS] = {
+	BYTES_TO_WORDS_8(FF, FF, FF, FF, FF, FF, FF, FF),
+	BYTES_TO_WORDS_8(FF, FF, FF, FF, 00, 00, 00, 00),
+	BYTES_TO_WORDS_8(00, 00, 00, 00, 00, 00, 00, 00),
+	BYTES_TO_WORDS_8(01, 00, 00, 00, FF, FF, FF, FF)
+};
+const uECC_word_t curve_n[NUM_ECC_WORDS] = {
+	BYTES_TO_WORDS_8(51, 25, 63, FC, C2, CA, B9, F3),
+	BYTES_TO_WORDS_8(84, 9E, 17, A7, AD, FA, E6, BC),
+	BYTES_TO_WORDS_8(FF, FF, FF, FF, FF, FF, FF, FF),
+	BYTES_TO_WORDS_8(00, 00, 00, 00, FF, FF, FF, FF)
+};
+const uECC_word_t curve_G[2 * NUM_ECC_WORDS] = {
+	BYTES_TO_WORDS_8(96, C2, 98, D8, 45, 39, A1, F4),
+	BYTES_TO_WORDS_8(A0, 33, EB, 2D, 81, 7D, 03, 77),
+	BYTES_TO_WORDS_8(F2, 40, A4, 63, E5, E6, BC, F8),
+	BYTES_TO_WORDS_8(47, 42, 2C, E1, F2, D1, 17, 6B),
+	BYTES_TO_WORDS_8(F5, 51, BF, 37, 68, 40, B6, CB),
+	BYTES_TO_WORDS_8(CE, 5E, 31, 6B, 57, 33, CE, 2B),
+	BYTES_TO_WORDS_8(16, 9E, 0F, 7C, 4A, EB, E7, 8E),
+	BYTES_TO_WORDS_8(9B, 7F, 1A, FE, E2, 42, E3, 4F)
+};
+const uECC_word_t curve_b[NUM_ECC_WORDS] = {
+	BYTES_TO_WORDS_8(4B, 60, D2, 27, 3E, 3C, CE, 3B),
+	BYTES_TO_WORDS_8(F6, B0, 53, CC, B0, 06, 1D, 65),
+	BYTES_TO_WORDS_8(BC, 86, 98, 76, 55, BD, EB, B3),
+	BYTES_TO_WORDS_8(E7, 93, 3A, AA, D8, 35, C6, 5A)
+};
+
+static int uECC_update_param_sha256(mbedtls_sha256_context *ctx,
+					const uECC_word_t val[NUM_ECC_WORDS])
+{
+	uint8_t bytes[NUM_ECC_BYTES];
+
+	uECC_vli_nativeToBytes(bytes, NUM_ECC_BYTES, val);
+	return mbedtls_sha256_update_ret(ctx, bytes, NUM_ECC_BYTES);
+}
+
+static int uECC_compute_param_sha256(unsigned char output[32])
+{
+	int ret = UECC_FAILURE;
+	mbedtls_sha256_context ctx;
+
+	mbedtls_sha256_init( &ctx );
+
+	if (mbedtls_sha256_starts_ret(&ctx, 0) != 0) {
+		goto exit;
+	}
+
+	if (uECC_update_param_sha256(&ctx, curve_p) != 0 ||
+		uECC_update_param_sha256(&ctx, curve_n) != 0 ||
+		uECC_update_param_sha256(&ctx, curve_G) != 0 ||
+		uECC_update_param_sha256(&ctx, curve_G + NUM_ECC_WORDS) != 0 ||
+		uECC_update_param_sha256(&ctx, curve_b) != 0)
+	{
+		goto exit;
+	}
+
+	if (mbedtls_sha256_finish_ret(&ctx, output) != 0) {
+		goto exit;
+	}
+
+	ret = UECC_SUCCESS;
+
+exit:
+	mbedtls_sha256_free( &ctx );
+
+	return ret;
+}
+
+/*
+ * Check integrity of curve parameters.
+ * Return 0 if everything's OK, non-zero otherwise.
+ */
+static int uECC_check_curve_integrity(void)
+{
+	unsigned char computed[32];
+	static const unsigned char reference[32] = {
+		0x2d, 0xa1, 0xa4, 0x64, 0x45, 0x28, 0x0d, 0xe1,
+		0x93, 0xf9, 0x29, 0x2f, 0xac, 0x3e, 0xe2, 0x92,
+		0x76, 0x0a, 0xe2, 0xbc, 0xce, 0x2a, 0xa2, 0xc6,
+		0x38, 0xf2, 0x19, 0x1d, 0x76, 0x72, 0x93, 0x49,
+	};
+	int diff = 0;
+	unsigned char tmp1, tmp2;
+	volatile unsigned i;
+
+	if (uECC_compute_param_sha256(computed) != UECC_SUCCESS) {
+		return UECC_FAILURE;
+	}
+
+	for (i = 0; i < 32; i++) {
+		/* make sure the order of volatile accesses is well-defined */
+		tmp1 = computed[i];
+		tmp2 = reference[i];
+		diff |= tmp1 ^ tmp2;
+	}
+
+	/* i should be 32 */
+	mbedtls_platform_random_delay();
+	diff |= i ^ 32;
+
+	return diff;
+}
+
+/* IMPORTANT: Make sure a cryptographically-secure PRNG is set and the platform
+ * has access to enough entropy in order to feed the PRNG regularly. */
+#if default_RNG_defined
+static uECC_RNG_Function g_rng_function = &default_CSPRNG;
+#else
+static uECC_RNG_Function g_rng_function = 0;
+#endif
+
+void uECC_set_rng(uECC_RNG_Function rng_function)
+{
+	g_rng_function = rng_function;
+}
+
+uECC_RNG_Function uECC_get_rng(void)
+{
+	return g_rng_function;
+}
+
+int uECC_curve_private_key_size(void)
+{
+	return BITS_TO_BYTES(NUM_ECC_BITS);
+}
+
+int uECC_curve_public_key_size(void)
+{
+	return 2 * NUM_ECC_BYTES;
+}
+
+#if defined MBEDTLS_OPTIMIZE_TINYCRYPT_ASM && defined __CC_ARM
+__asm void uECC_vli_clear(uECC_word_t *vli)
+{
+#if NUM_ECC_WORDS != 8
+#error adjust ARM assembly to handle NUM_ECC_WORDS != 8
+#endif
+#if !defined __thumb__ || __TARGET_ARCH_THUMB < 4
+    MOVS    r1,#0
+    MOVS    r2,#0
+    STMIA   r0!,{r1,r2}
+    STMIA   r0!,{r1,r2}
+    STMIA   r0!,{r1,r2}
+    STMIA   r0!,{r1,r2}
+    BX      lr
+#else
+    MOVS    r1,#0
+    STRD    r1,r1,[r0,#0]       // Only Thumb2 STRD can store same reg twice, not ARM
+    STRD    r1,r1,[r0,#8]
+    STRD    r1,r1,[r0,#16]
+    STRD    r1,r1,[r0,#24]
+    BX      lr
+#endif
+}
+#elif defined MBEDTLS_OPTIMIZE_TINYCRYPT_ASM && defined __GNUC__ && defined __arm__
+void uECC_vli_clear(uECC_word_t *vli)
+{
+#if NUM_ECC_WORDS != 8
+#error adjust ARM assembly to handle NUM_ECC_WORDS != 8
+#endif
+#if !defined __thumb__ || !defined __thumb2__
+    register uECC_word_t *r0 asm("r0") = vli;
+    register uECC_word_t r1 asm("r1") = 0;
+    register uECC_word_t r2 asm("r2") = 0;
+    asm volatile (
+    ".syntax unified            \n\t"
+    "STMIA   r0!,{r1,r2}        \n\t"
+    "STMIA   r0!,{r1,r2}        \n\t"
+    "STMIA   r0!,{r1,r2}        \n\t"
+    "STMIA   r0!,{r1,r2}        \n\t"
+    ".syntax divided            \n\t"
+    : "+r" (r0)
+    : "r" (r1), "r" (r2)
+    : "memory"
+#else
+    register uECC_word_t *r0 asm("r0") = vli;
+    register uECC_word_t r1 asm("r1") = 0;
+    asm volatile (
+    "STRD    r1,r1,[r0,#0]      \n\t" // Only Thumb2 STRD can store same reg twice, not ARM
+    "STRD    r1,r1,[r0,#8]      \n\t"
+    "STRD    r1,r1,[r0,#16]     \n\t"
+    "STRD    r1,r1,[r0,#24]     \n\t"
+    :
+    : "r" (r0), "r" (r1)
+    : "memory"
+#endif
+    );
+}
+#else
+void uECC_vli_clear(uECC_word_t *vli)
+{
+	wordcount_t i;
+	for (i = 0; i < NUM_ECC_WORDS; ++i) {
+		 vli[i] = 0;
+	}
+}
+#endif
+
+#if defined MBEDTLS_OPTIMIZE_TINYCRYPT_ASM && defined __CC_ARM
+__asm uECC_word_t uECC_vli_isZero(const uECC_word_t *vli)
+{
+#if NUM_ECC_WORDS != 8
+#error adjust ARM assembly to handle NUM_ECC_WORDS != 8
+#endif
+#if defined __thumb__ &&  __TARGET_ARCH_THUMB < 4
+    LDMIA   r0!,{r1,r2,r3}
+    ORRS    r1,r2
+    ORRS    r1,r3
+    LDMIA   r0!,{r2,r3}
+    ORRS    r1,r2
+    ORRS    r1,r3
+    LDMIA   r0,{r0,r2,r3}
+    ORRS    r1,r0
+    ORRS    r1,r2
+    ORRS    r1,r3
+    RSBS    r1,r1,#0      // C set if zero
+    MOVS    r0,#0
+    ADCS    r0,r0
+    BX      lr
+#else
+    LDMIA   r0!,{r1,r2,r3,ip}
+    ORRS    r1,r2
+    ORRS    r1,r3
+    ORRS    r1,ip
+    LDMIA   r0,{r0,r2,r3,ip}
+    ORRS    r1,r0
+    ORRS    r1,r2
+    ORRS    r1,r3
+    ORRS    r1,ip
+#ifdef __ARM_FEATURE_CLZ
+    CLZ     r0,r1           // 32 if zero
+    LSRS    r0,r0,#5
+#else
+    RSBS    r1,r1,#0      // C set if zero
+    MOVS    r0,#0
+    ADCS    r0,r0
+#endif
+    BX      lr
+#endif
+}
+#elif defined MBEDTLS_OPTIMIZE_TINYCRYPT_ASM && defined __GNUC__ && defined __arm__
+uECC_word_t uECC_vli_isZero(const uECC_word_t *vli)
+{
+    uECC_word_t ret;
+#if NUM_ECC_WORDS != 8
+#error adjust ARM assembly to handle NUM_ECC_WORDS != 8
+#endif
+#if defined __thumb__ && !defined __thumb2__
+    register uECC_word_t r1 asm ("r1");
+    register uECC_word_t r2 asm ("r2");
+    register uECC_word_t r3 asm ("r3");
+    asm volatile (
+    ".syntax unified                       \n\t"
+    "LDMIA   %[vli]!,{%[r1],%[r2],%[r3]}   \n\t"
+    "ORRS    %[r1],%[r2]                   \n\t"
+    "ORRS    %[r1],%[r3]                   \n\t"
+    "LDMIA   %[vli]!,{%[r2],%[r3]}         \n\t"
+    "ORRS    %[r1],%[r2]                   \n\t"
+    "ORRS    %[r1],%[r3]                   \n\t"
+    "LDMIA   %[vli],{%[vli],%[r2],%[r3]}   \n\t"
+    "ORRS    %[r1],%[vli]                  \n\t"
+    "ORRS    %[r1],%[r2]                   \n\t"
+    "ORRS    %[r1],%[r3]                   \n\t"
+    "RSBS    %[r1],%[r1],#0                \n\t"     // C set if zero
+    "MOVS    %[ret],#0                     \n\t"
+    "ADCS    %[ret],r0                     \n\t"
+    ".syntax divided                       \n\t"
+    : [ret]"=r" (ret), [r1]"=r" (r1), [r2]"=r" (r2), [r3]"=r" (r3)
+    : [vli]"[ret]" (vli)
+    : "cc", "memory"
+    );
+#else
+     register uECC_word_t r1 asm ("r1");
+     register uECC_word_t r2 asm ("r2");
+     register uECC_word_t r3 asm ("r3");
+     register uECC_word_t ip asm ("ip");
+     asm volatile (
+    "LDMIA   %[vli]!,{%[r1],%[r2],%[r3],%[ip]}\n\t"
+    "ORRS    %[r1],%[r2]                      \n\t"
+    "ORRS    %[r1],%[r3]                      \n\t"
+    "ORRS    %[r1],%[ip]                      \n\t"
+    "LDMIA   %[vli],{%[vli],%[r2],%[r3],%[ip]}\n\t"
+    "ORRS    %[r1],%[vli]                     \n\t"
+    "ORRS    %[r1],%[r2]                      \n\t"
+    "ORRS    %[r1],%[r3]                      \n\t"
+    "ORRS    %[r1],%[ip]                      \n\t"
+#if __ARM_ARCH >= 5
+    "CLZ     %[ret],%[r1]                     \n\t"     // r0 = 32 if zero
+    "LSRS    %[ret],%[ret],#5                 \n\t"
+#else
+    "RSBS    %[r1],%[r1],#0                   \n\t"     // C set if zero
+    "MOVS    %[ret],#0                        \n\t"
+    "ADCS    %[ret],r0                        \n\t"
+#endif
+    : [ret]"=r" (ret), [r1]"=r" (r1), [r2]"=r" (r2), [r3]"=r" (r3), [ip]"=r" (ip)
+    : [vli]"[ret]" (vli)
+    : "cc", "memory"
+    );
+#endif
+    return ret;
+}
+#else
+uECC_word_t uECC_vli_isZero(const uECC_word_t *vli)
+{
+	uECC_word_t bits = 0;
+	wordcount_t i;
+	for (i = 0; i < NUM_ECC_WORDS; ++i) {
+		bits |= vli[i];
+	}
+	return (bits == 0);
+}
+#endif
+
+uECC_word_t uECC_vli_testBit(const uECC_word_t *vli, bitcount_t bit)
+{
+	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
+		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
+}
+
+/* Counts the number of words in vli. */
+static wordcount_t vli_numDigits(const uECC_word_t *vli)
+{
+
+	wordcount_t i;
+	/* Search from the end until we find a non-zero digit. We do it in reverse
+	 * because we expect that most digits will be nonzero. */
+	for (i = NUM_ECC_WORDS - 1; i >= 0 && vli[i] == 0; --i) {
+	}
+
+	return (i + 1);
+}
+
+bitcount_t uECC_vli_numBits(const uECC_word_t *vli)
+{
+
+	uECC_word_t i;
+	uECC_word_t digit;
+
+	wordcount_t num_digits = vli_numDigits(vli);
+	if (num_digits == 0) {
+		return 0;
+	}
+
+	digit = vli[num_digits - 1];
+#if defined __GNUC__ || defined __clang__ || defined __CC_ARM
+	i = uECC_WORD_BITS - __builtin_clz(digit);
+#else
+	for (i = 0; digit; ++i) {
+		digit >>= 1;
+	}
+#endif
+
+	return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);
+}
+
+void uECC_vli_set(uECC_word_t *dest, const uECC_word_t *src)
+{
+	wordcount_t i;
+
+	for (i = 0; i < NUM_ECC_WORDS; ++i) {
+		dest[i] = src[i];
+  	}
+}
+
+cmpresult_t uECC_vli_cmp_unsafe(const uECC_word_t *left,
+				const uECC_word_t *right)
+{
+	wordcount_t i;
+
+	for (i = NUM_ECC_WORDS - 1; i >= 0; --i) {
+		if (left[i] > right[i]) {
+			return 1;
+		} else if (left[i] < right[i]) {
+			return -1;
+		}
+	}
+	return 0;
+}
+
+uECC_word_t uECC_vli_equal(const uECC_word_t *left, const uECC_word_t *right)
+{
+
+	uECC_word_t diff = 0;
+	uECC_word_t flow_monitor = 0;
+	uECC_word_t tmp1, tmp2;
+	volatile int i;
+
+	/* Start from a random location and check the correct number of iterations */
+	int start_offset = mbedtls_platform_random_in_range(NUM_ECC_WORDS);
+
+	for (i = start_offset; i < NUM_ECC_WORDS; ++i) {
+		tmp1 = left[i];
+		tmp2 = right[i];
+		flow_monitor++;
+		diff |= (tmp1 ^ tmp2);
+	}
+
+	for (i = 0; i < start_offset; ++i) {
+		tmp1 = left[i];
+		tmp2 = right[i];
+		flow_monitor++;
+		diff |= (tmp1 ^ tmp2);
+	}
+
+	/* Random delay to increase security */
+	mbedtls_platform_random_delay();
+
+	/* Return 0 only when diff is 0 and flow_counter is equal to NUM_ECC_WORDS */
+	return (diff | (flow_monitor ^ NUM_ECC_WORDS));
+}
+
+uECC_word_t cond_set(uECC_word_t p_true, uECC_word_t p_false, unsigned int cond)
+{
+	return (p_true*(cond)) | (p_false*(cond ^ 1));
+}
+
+/* Computes result = left - right, returning borrow, in constant time.
+ * Can modify in place. */
+#if defined MBEDTLS_OPTIMIZE_TINYCRYPT_ASM && defined __CC_ARM
+__asm uECC_word_t uECC_vli_sub(uECC_word_t *result, const uECC_word_t *left,
+                const uECC_word_t *right)
+{
+#if NUM_ECC_WORDS != 8
+#error adjust ARM assembly to handle NUM_ECC_WORDS != 8
+#endif
+#if defined __thumb__ &&  __TARGET_ARCH_THUMB < 4
+    PUSH    {r4-r6,lr}
+    FRAME   PUSH {r4-r6,lr}
+    LDMIA   r1!,{r3,r4}
+    LDMIA   r2!,{r5,r6}
+    SUBS    r3,r5
+    SBCS    r4,r6
+    STMIA   r0!,{r3,r4}
+    LDMIA   r1!,{r3,r4}
+    LDMIA   r2!,{r5,r6}
+    SBCS    r3,r5
+    SBCS    r4,r6
+    STMIA   r0!,{r3,r4}
+    LDMIA   r1!,{r3,r4}
+    LDMIA   r2!,{r5,r6}
+    SBCS    r3,r5
+    SBCS    r4,r6
+    STMIA   r0!,{r3,r4}
+    LDMIA   r1!,{r3,r4}
+    LDMIA   r2!,{r5,r6}
+    SBCS    r3,r5
+    SBCS    r4,r6
+    STMIA   r0!,{r3,r4}
+    SBCS    r0,r0           // r0 := r0 - r0 - borrow = -borrow
+    RSBS    r0,r0,#0        // r0 := borrow
+    POP     {r4-r6,pc}
+#else
+    PUSH    {r4-r8,lr}
+    FRAME   PUSH {r4-r8,lr}
+    LDMIA   r1!,{r3-r6}
+    LDMIA   r2!,{r7,r8,r12,lr}
+    SUBS    r3,r7
+    SBCS    r4,r8
+    SBCS    r5,r12
+    SBCS    r6,lr
+    STMIA   r0!,{r3-r6}
+    LDMIA   r1!,{r3-r6}
+    LDMIA   r2!,{r7,r8,r12,lr}
+    SBCS    r3,r7
+    SBCS    r4,r8
+    SBCS    r5,r12
+    SBCS    r6,lr
+    STMIA   r0!,{r3-r6}
+    SBCS    r0,r0           // r0 := r0 - r0 - borrow = -borrow
+    RSBS    r0,r0,#0        // r0 := borrow
+    POP     {r4-r8,pc}
+#endif
+}
+#elif defined MBEDTLS_OPTIMIZE_TINYCRYPT_ASM && defined __GNUC__ && defined __arm__
+uECC_word_t uECC_vli_sub(uECC_word_t *result, const uECC_word_t *left,
+             const uECC_word_t *right)
+{
+#if NUM_ECC_WORDS != 8
+#error adjust ARM assembly to handle NUM_ECC_WORDS != 8
+#endif
+    register uECC_word_t *r0 asm ("r0") = result;
+    register const uECC_word_t *r1 asm ("r1") = left;
+    register const uECC_word_t *r2 asm ("r2") = right;
+    asm volatile (
+#if defined __thumb__ && !defined __thumb2__
+    ".syntax unified         \n\t"
+    "LDMIA   r1!,{r3,r4}     \n\t"
+    "LDMIA   r2!,{r5,r6}     \n\t"
+    "SUBS    r3,r5           \n\t"
+    "SBCS    r4,r6           \n\t"
+    "STMIA   r0!,{r3,r4}     \n\t"
+    "LDMIA   r1!,{r3,r4}     \n\t"
+    "LDMIA   r2!,{r5,r6}     \n\t"
+    "SBCS    r3,r5           \n\t"
+    "SBCS    r4,r6           \n\t"
+    "STMIA   r0!,{r3,r4}     \n\t"
+    "LDMIA   r1!,{r3,r4}     \n\t"
+    "LDMIA   r2!,{r5,r6}     \n\t"
+    "SBCS    r3,r5           \n\t"
+    "SBCS    r4,r6           \n\t"
+    "STMIA   r0!,{r3,r4}     \n\t"
+    "LDMIA   r1!,{r3,r4}     \n\t"
+    "LDMIA   r2!,{r5,r6}     \n\t"
+    "SBCS    r3,r5           \n\t"
+    "SBCS    r4,r6           \n\t"
+    "STMIA   r0!,{r3,r4}     \n\t"
+    "SBCS    r0,r0           \n\t" // r0 := r0 - r0 - borrow = -borrow
+    "RSBS    r0,r0,#0        \n\t" // r0 := borrow
+    ".syntax divided         \n\t"
+    : "+r" (r0), "+r" (r1), "+r" (r2)
+    :
+    : "r3", "r4", "r5", "r6", "cc", "memory"
+#else
+    "LDMIA   r1!,{r3-r6}        \n\t"
+    "LDMIA   r2!,{r7,r8,r12,lr} \n\t"
+    "SUBS    r3,r7              \n\t"
+    "SBCS    r4,r8              \n\t"
+    "SBCS    r5,r12             \n\t"
+    "SBCS    r6,lr              \n\t"
+    "STMIA   r0!,{r3-r6}        \n\t"
+    "LDMIA   r1!,{r3-r6}        \n\t"
+    "LDMIA   r2!,{r7,r8,r12,lr} \n\t"
+    "SBCS    r3,r7              \n\t"
+    "SBCS    r4,r8              \n\t"
+    "SBCS    r5,r12             \n\t"
+    "SBCS    r6,lr              \n\t"
+    "STMIA   r0!,{r3-r6}        \n\t"
+    "SBCS    r0,r0              \n\t" // r0 := r0 - r0 - borrow = -borrow
+    "RSBS    r0,r0,#0           \n\t" // r0 := borrow
+    : "+r" (r0), "+r" (r1), "+r" (r2)
+    :
+    : "r3", "r4", "r5", "r6", "r7", "r8", "r12", "lr", "cc", "memory"
+#endif
+    );
+    return (uECC_word_t) r0;
+}
+#else
+uECC_word_t uECC_vli_sub(uECC_word_t *result, const uECC_word_t *left,
+			 const uECC_word_t *right)
+{
+	uECC_word_t borrow = 0;
+	wordcount_t i;
+	for (i = 0; i < NUM_ECC_WORDS; ++i) {
+		uECC_word_t diff = left[i] - right[i] - borrow;
+		uECC_word_t val = (diff > left[i]);
+		borrow = cond_set(val, borrow, (diff != left[i]));
+
+		result[i] = diff;
+	}
+	return borrow;
+}
+#endif
+
+/* Computes result = left + right, returning carry, in constant time.
+ * Can modify in place. */
+#if defined MBEDTLS_OPTIMIZE_TINYCRYPT_ASM && defined __CC_ARM
+static __asm uECC_word_t uECC_vli_add(uECC_word_t *result, const uECC_word_t *left,
+                const uECC_word_t *right)
+{
+#if NUM_ECC_WORDS != 8
+#error adjust ARM assembly to handle NUM_ECC_WORDS != 8
+#endif
+#if defined __thumb__ &&  __TARGET_ARCH_THUMB < 4
+    PUSH    {r4-r6,lr}
+    FRAME   PUSH {r4-r6,lr}
+    LDMIA   r1!,{r3,r4}
+    LDMIA   r2!,{r5,r6}
+    ADDS    r3,r5
+    ADCS    r4,r6
+    STMIA   r0!,{r3,r4}
+    LDMIA   r1!,{r3,r4}
+    LDMIA   r2!,{r5,r6}
+    ADCS    r3,r5
+    ADCS    r4,r6
+    STMIA   r0!,{r3,r4}
+    LDMIA   r1!,{r3,r4}
+    LDMIA   r2!,{r5,r6}
+    ADCS    r3,r5
+    ADCS    r4,r6
+    STMIA   r0!,{r3,r4}
+    LDMIA   r1!,{r3,r4}
+    LDMIA   r2!,{r5,r6}
+    ADCS    r3,r5
+    ADCS    r4,r6
+    STMIA   r0!,{r3,r4}
+    MOVS    r0,#0           // does not affect C flag
+    ADCS    r0,r0           // r0 := 0 + 0 + C = carry
+    POP     {r4-r6,pc}
+#else
+    PUSH    {r4-r8,lr}
+    FRAME   PUSH {r4-r8,lr}
+    LDMIA   r1!,{r3-r6}
+    LDMIA   r2!,{r7,r8,r12,lr}
+    ADDS    r3,r7
+    ADCS    r4,r8
+    ADCS    r5,r12
+    ADCS    r6,lr
+    STMIA   r0!,{r3-r6}
+    LDMIA   r1!,{r3-r6}
+    LDMIA   r2!,{r7,r8,r12,lr}
+    ADCS    r3,r7
+    ADCS    r4,r8
+    ADCS    r5,r12
+    ADCS    r6,lr
+    STMIA   r0!,{r3-r6}
+    MOVS    r0,#0           // does not affect C flag
+    ADCS    r0,r0           // r0 := 0 + 0 + C = carry
+    POP     {r4-r8,pc}
+#endif
+}
+#elif defined MBEDTLS_OPTIMIZE_TINYCRYPT_ASM && defined __GNUC__ && defined __arm__
+static uECC_word_t uECC_vli_add(uECC_word_t *result, const uECC_word_t *left,
+                const uECC_word_t *right)
+{
+    register uECC_word_t *r0 asm ("r0") = result;
+    register const uECC_word_t *r1 asm ("r1") = left;
+    register const uECC_word_t *r2 asm ("r2") = right;
+
+    asm volatile (
+#if defined __thumb__ && !defined __thumb2__
+    ".syntax unified         \n\t"
+    "LDMIA   r1!,{r3,r4}     \n\t"
+    "LDMIA   r2!,{r5,r6}     \n\t"
+    "ADDS    r3,r5           \n\t"
+    "ADCS    r4,r6           \n\t"
+    "STMIA   r0!,{r3,r4}     \n\t"
+    "LDMIA   r1!,{r3,r4}     \n\t"
+    "LDMIA   r2!,{r5,r6}     \n\t"
+    "ADCS    r3,r5           \n\t"
+    "ADCS    r4,r6           \n\t"
+    "STMIA   r0!,{r3,r4}     \n\t"
+    "LDMIA   r1!,{r3,r4}     \n\t"
+    "LDMIA   r2!,{r5,r6}     \n\t"
+    "ADCS    r3,r5           \n\t"
+    "ADCS    r4,r6           \n\t"
+    "STMIA   r0!,{r3,r4}     \n\t"
+    "LDMIA   r1!,{r3,r4}     \n\t"
+    "LDMIA   r2!,{r5,r6}     \n\t"
+    "ADCS    r3,r5           \n\t"
+    "ADCS    r4,r6           \n\t"
+    "STMIA   r0!,{r3,r4}     \n\t"
+    "MOVS    r0,#0           \n\t"  // does not affect C flag
+    "ADCS    r0,r0           \n\t"  // r0 := 0 + 0 + C = carry
+    ".syntax divided         \n\t"
+    : "+r" (r0), "+r" (r1), "+r" (r2)
+    :
+    : "r3", "r4", "r5", "r6", "cc", "memory"
+#else
+    "LDMIA   r1!,{r3-r6}        \n\t"
+    "LDMIA   r2!,{r7,r8,r12,lr} \n\t"
+    "ADDS    r3,r7              \n\t"
+    "ADCS    r4,r8              \n\t"
+    "ADCS    r5,r12             \n\t"
+    "ADCS    r6,lr              \n\t"
+    "STMIA   r0!,{r3-r6}        \n\t"
+    "LDMIA   r1!,{r3-r6}        \n\t"
+    "LDMIA   r2!,{r7,r8,r12,lr} \n\t"
+    "ADCS    r3,r7              \n\t"
+    "ADCS    r4,r8              \n\t"
+    "ADCS    r5,r12             \n\t"
+    "ADCS    r6,lr              \n\t"
+    "STMIA   r0!,{r3-r6}        \n\t"
+    "MOVS    r0,#0              \n\t"   // does not affect C flag
+    "ADCS    r0,r0              \n\t"   // r0 := 0 + 0 + C = carry
+    : "+r" (r0), "+r" (r1), "+r" (r2)
+    :
+    : "r3", "r4", "r5", "r6", "r7", "r8", "r12", "lr", "cc", "memory"
+#endif
+    );
+    return (uECC_word_t) r0;
+}
+#else
+static uECC_word_t uECC_vli_add(uECC_word_t *result, const uECC_word_t *left,
+				const uECC_word_t *right)
+{
+	uECC_word_t carry = 0;
+	wordcount_t i;
+	for (i = 0; i < NUM_ECC_WORDS; ++i) {
+		uECC_word_t sum = left[i] + right[i] + carry;
+		uECC_word_t val = (sum < left[i]);
+		carry = cond_set(val, carry, (sum != left[i]));
+		result[i] = sum;
+	}
+	return carry;
+}
+#endif
+
+cmpresult_t uECC_vli_cmp(const uECC_word_t *left, const uECC_word_t *right)
+{
+	uECC_word_t tmp[NUM_ECC_WORDS];
+	uECC_word_t neg = uECC_vli_sub(tmp, left, right);
+	uECC_word_t equal = uECC_vli_isZero(tmp);
+	return ((equal ^ 1) - 2 * neg);
+}
+
+/* Computes vli = vli >> 1. */
+#if defined MBEDTLS_OPTIMIZE_TINYCRYPT_ASM && defined __CC_ARM
+static __asm void uECC_vli_rshift1(uECC_word_t *vli)
+{
+#if defined __thumb__ &&  __TARGET_ARCH_THUMB < 4
+// RRX instruction is not available, so although we
+// can use C flag, it's not that effective. Does at
+// least save one working register, meaning we don't need stack
+    MOVS    r3,#0           // initial carry = 0
+    MOVS    r2,#__cpp(4 * (NUM_ECC_WORDS - 1))
+01  LDR     r1,[r0,r2]
+    LSRS    r1,r1,#1        // r2 = word >> 1
+    ORRS    r1,r3           // merge in the previous carry
+    STR     r1,[r0,r2]
+    ADCS    r3,r3           // put C into bottom bit of r3
+    LSLS    r3,r3,#31       // shift it up to the top ready for next word
+    SUBS    r2,r2,#4
+    BPL     %B01
+    BX      lr
+#else
+#if NUM_ECC_WORDS != 8
+#error adjust ARM assembly to handle NUM_ECC_WORDS != 8
+#endif
+// Smooth multiword operation, lots of 32-bit instructions
+    ADDS    r0,#32
+    LDMDB   r0,{r1-r3,ip}
+    LSRS    ip,ip,#1
+    RRXS    r3,r3
+    RRXS    r2,r2
+    RRXS    r1,r1
+    STMDB   r0!,{r1-r3,ip}
+    LDMDB   r0,{r1-r3,ip}
+    RRXS    ip,ip
+    RRXS    r3,r3
+    RRXS    r2,r2
+    RRX     r1,r1
+    STMDB   r0!,{r1-r3,ip}
+    BX      lr
+#endif
+}
+#elif defined MBEDTLS_OPTIMIZE_TINYCRYPT_ASM && defined __GNUC__ && defined __arm__ && defined __thumb2__
+static void uECC_vli_rshift1(uECC_word_t *vli)
+{
+    register uECC_word_t *r0 asm ("r0") = vli;
+#if NUM_ECC_WORDS != 8
+#error adjust ARM assembly to handle NUM_ECC_WORDS != 8
+#endif
+    asm volatile (
+    "ADDS    r0,#32           \n\t"
+    "LDMDB   r0,{r1-r3,ip}    \n\t"
+    "LSRS    ip,ip,#1         \n\t"
+    "RRXS    r3,r3            \n\t"
+    "RRXS    r2,r2            \n\t"
+    "RRXS    r1,r1            \n\t"
+    "STMDB   r0!,{r1-r3,ip}   \n\t"
+    "LDMDB   r0,{r1-r3,ip}    \n\t"
+    "RRXS    ip,ip            \n\t"
+    "RRXS    r3,r3            \n\t"
+    "RRXS    r2,r2            \n\t"
+    "RRX     r1,r1            \n\t"
+    "STMDB   r0!,{r1-r3,ip}   \n\t"
+    : "+r" (r0)
+    :
+    : "r1", "r2", "r3", "ip", "cc", "memory"
+    );
+}
+#else
+static void uECC_vli_rshift1(uECC_word_t *vli)
+{
+	uECC_word_t *end = vli;
+	uECC_word_t carry = 0;
+
+	vli += NUM_ECC_WORDS;
+	while (vli-- > end) {
+		uECC_word_t temp = *vli;
+		*vli = (temp >> 1) | carry;
+		carry = temp << (uECC_WORD_BITS - 1);
+	}
+}
+#endif
+
+/* Compute a * b + r, where r is a triple-word with high-order word r[2] and
+ * low-order word r[0], and store the result in the same triple-word.
+ *
+ * r[2..0] = a * b + r[2..0]:
+ * [in] a, b: operands to be multiplied
+ * [in] r: 3 words of operand to add
+ * [out] r: 3 words of result
+ */
+#if defined MBEDTLS_OPTIMIZE_TINYCRYPT_ASM && defined __CC_ARM
+static __asm void muladd(uECC_word_t a, uECC_word_t b, uECC_word_t r[3])
+{
+#if defined __thumb__ &&  __TARGET_ARCH_THUMB < 4
+    PUSH    {r4-r5}
+    FRAME   PUSH {r4-r5}
+    // __ARM_common_mul_uu replacement - inline, faster, don't touch R2
+    // Separate operands into halfwords
+    UXTH    r3,r0               // r3 := a.lo
+    LSRS    r4,r0,#16           // r4 := a.hi
+    UXTH    r5,r1               // r5 := b.lo
+    LSRS    r1,r1,#16           // r1 := b.hi
+    // Multiply halfword pairs
+    MOVS    r0,r3
+    MULS    r0,r5,r0            // r0 := a.lo * b.lo
+    MULS    r3,r1,r3            // r3 := a.lo * b.hi
+    MULS    r5,r4,r5            // r5 := a.hi * b.lo
+    MULS    r1,r4,r1            // r1 := a.hi * b.hi
+    // Split, shift and add a.lo * b.hi
+    LSRS    r4,r3,#16           // r4 := (a.lo * b.hi).hi
+    LSLS    r3,r3,#16           // r3 := (a.lo * b.hi).lo
+    ADDS    r0,r0,r3            // r0 := a.lo * b.lo + (a.lo * b.hi).lo
+    ADCS    r1,r4               // r1 := a.hi * b.hi + (a.lo * b.hi).hi + carry
+    // Split, shift and add a.hi * b.lo
+    LSRS    r4,r5,#16           // r4 := (a.hi * b.lo).hi
+    LSLS    r5,r5,#16           // r5 := (a.hi * b.lo).lo
+    ADDS    r0,r0,r5            // r0 := a.lo * b.lo + (a.lo * b.hi).lo + (a.hi * b.lo).lo
+    ADCS    r1,r4               // r1 := a.hi * b.hi + (a.lo * b.hi).hi + (a.hi * b.lo).hi + carries
+    // Finally add r[]
+    LDMIA   r2!,{r3,r4,r5}
+    ADDS    r3,r3,r0
+    ADCS    r4,r1
+    MOVS    r0,#0
+    ADCS    r5,r0
+    SUBS    r2,#12
+    STMIA   r2!,{r3,r4,r5}
+    POP     {r4-r5}
+    FRAME   POP {r4-r5}
+    BX      lr
+#else
+    UMULL   r3,ip,r0,r1 // pre-ARMv6 requires Rd[Lo|Hi] != Rn
+    LDMIA   r2,{r0,r1}
+    ADDS    r0,r0,r3
+    LDR     r3,[r2,#8]
+    ADCS    r1,r1,ip
+    ADC     r3,r3,#0
+    STMIA   r2!,{r0,r1,r3}
+    BX      lr
+#endif
+}
+#elif defined MBEDTLS_OPTIMIZE_TINYCRYPT_ASM && defined __GNUC__ && defined __arm__
+static void muladd(uECC_word_t a, uECC_word_t b, uECC_word_t r[3])
+{
+    register uECC_word_t r0 asm ("r0") = a;
+    register uECC_word_t r1 asm ("r1") = b;
+    register uECC_word_t *r2 asm ("r2") = r;
+    asm volatile (
+#if defined __thumb__ && !defined(__thumb2__)
+    ".syntax unified             \n\t"
+    // __ARM_common_mul_uu replacement - inline, faster, don't touch R2
+    // Separate operands into halfwords
+    "UXTH    r3,r0               \n\t" // r3 := a.lo
+    "LSRS    r4,r0,#16           \n\t" // r4 := a.hi
+    "UXTH    r5,r1               \n\t" // r5 := b.lo
+    "LSRS    r1,r1,#16           \n\t" // r1 := b.hi
+    // Multiply halfword pairs
+    "MOVS    r0,r3               \n\t"
+    "MULS    r0,r5,r0            \n\t" // r0 := a.lo * b.lo
+    "MULS    r3,r1,r3            \n\t" // r3 := a.lo * b.hi
+    "MULS    r5,r4,r5            \n\t" // r5 := a.hi * b.lo
+    "MULS    r1,r4,r1            \n\t" // r1 := a.hi * b.hi
+    // Split, shift and add a.lo * b.hi
+    "LSRS    r4,r3,#16           \n\t" // r4 := (a.lo * b.hi).hi
+    "LSLS    r3,r3,#16           \n\t" // r3 := (a.lo * b.hi).lo
+    "ADDS    r0,r0,r3            \n\t" // r0 := a.lo * b.lo + (a.lo * b.hi).lo
+    "ADCS    r1,r4               \n\t" // r1 := a.hi * b.hi + (a.lo * b.hi).hi + carry
+    // Split, shift and add a.hi * b.lo
+    "LSRS    r4,r5,#16           \n\t" // r4 := (a.hi * b.lo).hi
+    "LSLS    r5,r5,#16           \n\t" // r5 := (a.hi * b.lo).lo
+    "ADDS    r0,r0,r5            \n\t" // r0 := a.lo * b.lo + (a.lo * b.hi).lo + (a.hi * b.lo).lo
+    "ADCS    r1,r4               \n\t" // r1 := a.hi * b.hi + (a.lo * b.hi).hi + (a.hi * b.lo).hi + carries
+    // Finally add r[]
+    "LDMIA   r2!,{r3,r4,r5}      \n\t"
+    "ADDS    r3,r3,r0            \n\t"
+    "ADCS    r4,r1               \n\t"
+    "MOVS    r0,#0               \n\t"
+    "ADCS    r5,r0               \n\t"
+    "SUBS    r2,#12              \n\t"
+    "STMIA   r2!,{r3,r4,r5}      \n\t"
+    ".syntax divided             \n\t"
+    : "+r" (r0), "+r" (r1), "+r" (r2)
+    :
+    : "r3", "r4", "r5", "ip", "cc", "memory"
+#else
+    "UMULL   r3,ip,r0,r1         \n\t" // pre-ARMv6 requires Rd[Lo|Hi] != Rn
+    "LDMIA   r2,{r0,r1}          \n\t"
+    "ADDS    r0,r0,r3            \n\t"
+    "LDR     r3,[r2,#8]          \n\t"
+    "ADCS    r1,r1,ip            \n\t"
+    "ADC     r3,r3,#0            \n\t"
+    "STMIA   r2!,{r0,r1,r3}      \n\t"
+    : "+r" (r0), "+r" (r1), "+r" (r2)
+    :
+    : "r3", "ip", "cc", "memory"
+#endif
+    );
+}
+#else
+static void muladd(uECC_word_t a, uECC_word_t b, uECC_word_t r[3])
+{
+
+	uECC_dword_t p = (uECC_dword_t)a * b;
+	uECC_dword_t r01 = ((uECC_dword_t)(r[1]) << uECC_WORD_BITS) | r[0];
+	r01 += p;
+	r[2] += (r01 < p);
+	r[1] = r01 >> uECC_WORD_BITS;
+	r[0] = (uECC_word_t)r01;
+}
+#endif
+
+/* State for implementing random delays in uECC_vli_mult_rnd().
+ *
+ * The state is initialized by randomizing delays and setting i = 0.
+ * Each call to uECC_vli_mult_rnd() uses one byte of delays and increments i.
+ *
+ * Randomized vli multiplication is used only for point operations
+ * (XYcZ_add_rnd() * and XYcZ_addC_rnd()) in scalar multiplication
+ * (ECCPoint_mult()). Those go in pair, and each pair does 14 calls to
+ * uECC_vli_mult_rnd() (6 in XYcZ_add_rnd() and 8 in XYcZ_addC_rnd(),
+ * indirectly through uECC_vli_modMult_rnd().
+ *
+ * Considering this, in order to minimize the number of calls to the RNG
+ * (which impact performance) while keeping the size of the structure low,
+ * make room for 14 randomized vli mults, which corresponds to one step in the
+ * scalar multiplication routine.
+ */
+typedef struct {
+	uint8_t i;
+	uint8_t delays[14];
+} ecc_wait_state_t;
+
+/*
+ * Reset wait_state so that it's ready to be used.
+ */
+void ecc_wait_state_reset(ecc_wait_state_t *ws)
+{
+	if (ws == NULL)
+		return;
+
+	ws->i = 0;
+	mbedtls_platform_random_buf(ws->delays, sizeof(ws->delays));
+}
+
+/* Computes result = left * right. Result must be 2 * num_words long.
+ *
+ * As a counter-measure against horizontal attacks, add noise by performing
+ * a random number of extra computations performing random additional accesses
+ * to limbs of the input.
+ *
+ * Each of the two actual computation loops is surrounded by two
+ * similar-looking waiting loops, to make the beginning and end of the actual
+ * computation harder to spot.
+ *
+ * We add 4 waiting loops of between 0 and 3 calls to muladd() each. That
+ * makes an average of 6 extra calls. Compared to the main computation which
+ * makes 64 such calls, this represents an average performance degradation of
+ * less than 10%.
+ *
+ * Compared to the original uECC_vli_mult(), loose the num_words argument as we
+ * know it's always 8. This saves a bit of code size and execution speed.
+ */
+static void uECC_vli_mult_rnd(uECC_word_t *result, const uECC_word_t *left,
+				  const uECC_word_t *right, ecc_wait_state_t *s)
+{
+
+	uECC_word_t r[3] = { 0, 0, 0 };
+	wordcount_t i, k;
+	const uint8_t num_words = NUM_ECC_WORDS;
+
+	/* Fetch 8 bit worth of delay from the state; 0 if we have no state */
+	uint8_t delays = s ? s->delays[s->i++] : 0;
+	uECC_word_t rr[3] = { 0, 0, 0 };
+	volatile uECC_word_t rdummy;
+
+	/* Mimic start of next loop: k in [0, 3] */
+	k = 0 + (delays & 0x03);
+	delays >>= 2;
+	/* k = 0 -> i in [1, 0] -> 0 extra muladd;
+	 * k = 3 -> i in [1, 3] -> 3 extra muladd */
+	for (i = 1; i <= k; ++i) {
+		muladd(left[i], right[k - i], rr);
+	}
+	rdummy = rr[0];
+	rr[0] = rr[1];
+	rr[1] = rr[2];
+	rr[2] = 0;
+
+	/* Compute each digit of result in sequence, maintaining the carries. */
+	for (k = 0; k < num_words; ++k) {
+		for (i = 0; i <= k; ++i) {
+			muladd(left[i], right[k - i], r);
+		}
+
+		result[k] = r[0];
+		r[0] = r[1];
+		r[1] = r[2];
+		r[2] = 0;
+	}
+
+	/* Mimic end of previous loop: k in [4, 7] */
+	k = 4 + (delays & 0x03);
+	delays >>= 2;
+	/* k = 4 -> i in [5, 4] -> 0 extra muladd;
+	 * k = 7 -> i in [5, 7] -> 3 extra muladd */
+	for (i = 5; i <= k; ++i) {
+		muladd(left[i], right[k - i], rr);
+	}
+	rdummy = rr[0];
+	rr[0] = rr[1];
+	rr[1] = rr[2];
+	rr[2] = 0;
+
+	/* Mimic start of next loop: k in [8, 11] */
+	k = 11 - (delays & 0x03);
+	delays >>= 2;
+	/* k =  8 -> i in [5, 7] -> 3 extra muladd;
+	 * k = 11 -> i in [8, 7] -> 0 extra muladd */
+	for (i = (k + 5) - num_words; i < num_words; ++i) {
+		muladd(left[i], right[k - i], rr);
+	}
+	rdummy = rr[0];
+	rr[0] = rr[1];
+	rr[1] = rr[2];
+	rr[2] = 0;
+
+	for (k = num_words; k < num_words * 2 - 1; ++k) {
+
+		for (i = (k + 1) - num_words; i < num_words; ++i) {
+			muladd(left[i], right[k - i], r);
+		}
+		result[k] = r[0];
+		r[0] = r[1];
+		r[1] = r[2];
+		r[2] = 0;
+	}
+
+	result[num_words * 2 - 1] = r[0];
+
+	/* Mimic end of previous loop: k in [12, 15] */
+	k = 15 - (delays & 0x03);
+	delays >>= 2;
+	/* k = 12 -> i in [5, 7] -> 3 extra muladd;
+	 * k = 15 -> i in [8, 7] -> 0 extra muladd */
+	for (i = (k + 1) - num_words; i < num_words; ++i) {
+		muladd(left[i], right[k - i], rr);
+	}
+	rdummy = rr[0];
+	rr[0] = rr[1];
+	rr[1] = rr[2];
+	rr[2] = 0;
+
+	/* avoid warning that rdummy is set but not used */
+	(void) rdummy;
+}
+
+void uECC_vli_modAdd(uECC_word_t *result, const uECC_word_t *left,
+			 const uECC_word_t *right, const uECC_word_t *mod)
+{
+	uECC_word_t carry = uECC_vli_add(result, left, right);
+	if (carry || uECC_vli_cmp_unsafe(mod, result) != 1) {
+	/* result > mod (result = mod + remainder), so subtract mod to get
+	 * remainder. */
+		uECC_vli_sub(result, result, mod);
+	}
+}
+
+void uECC_vli_modSub(uECC_word_t *result, const uECC_word_t *left,
+			 const uECC_word_t *right, const uECC_word_t *mod)
+{
+	uECC_word_t l_borrow = uECC_vli_sub(result, left, right);
+	if (l_borrow) {
+		/* In this case, result == -diff == (max int) - diff. Since -x % d == d - x,
+		 * we can get the correct result from result + mod (with overflow). */
+		uECC_vli_add(result, result, mod);
+	}
+}
+
+/* Computes result = product % mod, where product is 2N words long. */
+/* Currently only designed to work for curve_p or curve_n. */
+void uECC_vli_mmod(uECC_word_t *result, uECC_word_t *product,
+			   const uECC_word_t *mod)
+{
+	uECC_word_t mod_multiple[2 * NUM_ECC_WORDS];
+	uECC_word_t tmp[2 * NUM_ECC_WORDS];
+	uECC_word_t *v[2] = {tmp, product};
+	uECC_word_t index;
+	const wordcount_t num_words = NUM_ECC_WORDS;
+
+	/* Shift mod so its highest set bit is at the maximum position. */
+	bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) -
+			   uECC_vli_numBits(mod);
+	wordcount_t word_shift = shift / uECC_WORD_BITS;
+	wordcount_t bit_shift = shift % uECC_WORD_BITS;
+	uECC_word_t carry = 0;
+
+	if(word_shift > NUM_ECC_WORDS)
+	{
+		mbedtls_platform_fault();
+	}
+
+	uECC_vli_clear(mod_multiple);
+	if (bit_shift > 0) {
+		for(index = 0; index < (uECC_word_t)num_words; ++index) {
+			mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
+			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
+		}
+	} else {
+		uECC_vli_set(mod_multiple + word_shift, mod);
+	}
+
+	for (index = 1; shift >= 0; --shift) {
+		uECC_word_t borrow = 0;
+		wordcount_t i;
+		for (i = 0; i < num_words * 2; ++i) {
+			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
+			if (diff != v[index][i]) {
+				borrow = (diff > v[index][i]);
+			}
+			v[1 - index][i] = diff;
+		}
+		/* Swap the index if there was no borrow */
+		index = !(index ^ borrow);
+		uECC_vli_rshift1(mod_multiple);
+		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
+						   (uECC_WORD_BITS - 1);
+		uECC_vli_rshift1(mod_multiple + num_words);
+	}
+	uECC_vli_set(result, v[index]);
+}
+
+void uECC_vli_modMult(uECC_word_t *result, const uECC_word_t *left,
+			  const uECC_word_t *right, const uECC_word_t *mod)
+{
+	uECC_word_t product[2 * NUM_ECC_WORDS];
+	uECC_vli_mult_rnd(product, left, right, NULL);
+	uECC_vli_mmod(result, product, mod);
+}
+
+static void uECC_vli_modMult_rnd(uECC_word_t *result, const uECC_word_t *left,
+				 const uECC_word_t *right, ecc_wait_state_t *s)
+{
+	uECC_word_t product[2 * NUM_ECC_WORDS];
+	uECC_vli_mult_rnd(product, left, right, s);
+
+	vli_mmod_fast_secp256r1(result, product);
+}
+
+void uECC_vli_modMult_fast(uECC_word_t *result, const uECC_word_t *left,
+			   const uECC_word_t *right)
+{
+	uECC_vli_modMult_rnd(result, left, right, NULL);
+}
+
+#define EVEN(vli) (!(vli[0] & 1))
+
+static void vli_modInv_update(uECC_word_t *uv,
+				  const uECC_word_t *mod)
+{
+
+	uECC_word_t carry = 0;
+
+	if (!EVEN(uv)) {
+		carry = uECC_vli_add(uv, uv, mod);
+	}
+	uECC_vli_rshift1(uv);
+	if (carry) {
+		uv[NUM_ECC_WORDS - 1] |= HIGH_BIT_SET;
+	}
+}
+
+void uECC_vli_modInv(uECC_word_t *result, const uECC_word_t *input,
+			 const uECC_word_t *mod)
+{
+	uECC_word_t a[NUM_ECC_WORDS], b[NUM_ECC_WORDS];
+	uECC_word_t u[NUM_ECC_WORDS], v[NUM_ECC_WORDS];
+	cmpresult_t cmpResult;
+
+	if (uECC_vli_isZero(input)) {
+		uECC_vli_clear(result);
+		return;
+	}
+
+	uECC_vli_set(a, input);
+	uECC_vli_set(b, mod);
+	uECC_vli_clear(u);
+	u[0] = 1;
+	uECC_vli_clear(v);
+	while ((cmpResult = uECC_vli_cmp_unsafe(a, b)) != 0) {
+		if (EVEN(a)) {
+			uECC_vli_rshift1(a);
+	  			vli_modInv_update(u, mod);
+			} else if (EVEN(b)) {
+			uECC_vli_rshift1(b);
+			vli_modInv_update(v, mod);
+		} else if (cmpResult > 0) {
+			uECC_vli_sub(a, a, b);
+			uECC_vli_rshift1(a);
+			if (uECC_vli_cmp_unsafe(u, v) < 0) {
+					uECC_vli_add(u, u, mod);
+	  			}
+	  			uECC_vli_sub(u, u, v);
+	  			vli_modInv_update(u, mod);
+			} else {
+	  			uECC_vli_sub(b, b, a);
+	  			uECC_vli_rshift1(b);
+	  			if (uECC_vli_cmp_unsafe(v, u) < 0) {
+					uECC_vli_add(v, v, mod);
+	  			}
+	  			uECC_vli_sub(v, v, u);
+	  			vli_modInv_update(v, mod);
+			}
+  	}
+  	uECC_vli_set(result, u);
+}
+
+/* ------ Point operations ------ */
+
+void double_jacobian_default(uECC_word_t * X1, uECC_word_t * Y1,
+				 uECC_word_t * Z1)
+{
+	/* t1 = X, t2 = Y, t3 = Z */
+	uECC_word_t t4[NUM_ECC_WORDS];
+	uECC_word_t t5[NUM_ECC_WORDS];
+	wordcount_t num_words = NUM_ECC_WORDS;
+
+	if (uECC_vli_isZero(Z1)) {
+		return;
+	}
+
+	uECC_vli_modMult_fast(t4, Y1, Y1);   /* t4 = y1^2 */
+	uECC_vli_modMult_fast(t5, X1, t4); /* t5 = x1*y1^2 = A */
+	uECC_vli_modMult_fast(t4, t4, t4);   /* t4 = y1^4 */
+	uECC_vli_modMult_fast(Y1, Y1, Z1); /* t2 = y1*z1 = z3 */
+	uECC_vli_modMult_fast(Z1, Z1, Z1);   /* t3 = z1^2 */
+
+	uECC_vli_modAdd(X1, X1, Z1, curve_p); /* t1 = x1 + z1^2 */
+	uECC_vli_modAdd(Z1, Z1, Z1, curve_p); /* t3 = 2*z1^2 */
+	uECC_vli_modSub(Z1, X1, Z1, curve_p); /* t3 = x1 - z1^2 */
+	uECC_vli_modMult_fast(X1, X1, Z1); /* t1 = x1^2 - z1^4 */
+
+	uECC_vli_modAdd(Z1, X1, X1, curve_p); /* t3 = 2*(x1^2 - z1^4) */
+	uECC_vli_modAdd(X1, X1, Z1, curve_p); /* t1 = 3*(x1^2 - z1^4) */
+	if (uECC_vli_testBit(X1, 0)) {
+		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve_p);
+		uECC_vli_rshift1(X1);
+		X1[num_words - 1] |= l_carry << (uECC_WORD_BITS - 1);
+	} else {
+		uECC_vli_rshift1(X1);
+	}
+
+	/* t1 = 3/2*(x1^2 - z1^4) = B */
+	uECC_vli_modMult_fast(Z1, X1, X1); /* t3 = B^2 */
+	uECC_vli_modSub(Z1, Z1, t5, curve_p); /* t3 = B^2 - A */
+	uECC_vli_modSub(Z1, Z1, t5, curve_p); /* t3 = B^2 - 2A = x3 */
+	uECC_vli_modSub(t5, t5, Z1, curve_p); /* t5 = A - x3 */
+	uECC_vli_modMult_fast(X1, X1, t5); /* t1 = B * (A - x3) */
+	/* t4 = B * (A - x3) - y1^4 = y3: */
+	uECC_vli_modSub(t4, X1, t4, curve_p);
+
+	uECC_vli_set(X1, Z1);
+	uECC_vli_set(Z1, Y1);
+	uECC_vli_set(Y1, t4);
+}
+
+/*
+ * @brief Computes x^3 + ax + b. result must not overlap x.
+ * @param result OUT -- x^3 + ax + b
+ * @param x IN -- value of x
+ * @param curve IN -- elliptic curve
+ */
+static void x_side_default(uECC_word_t *result,
+			const uECC_word_t *x)
+{
+	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
+
+	uECC_vli_modMult_fast(result, x, x); /* r = x^2 */
+	uECC_vli_modSub(result, result, _3, curve_p); /* r = x^2 - 3 */
+	uECC_vli_modMult_fast(result, result, x); /* r = x^3 - 3x */
+	/* r = x^3 - 3x + b: */
+	uECC_vli_modAdd(result, result, curve_b, curve_p);
+}
+
+void vli_mmod_fast_secp256r1(unsigned int *result, unsigned int*product)
+{
+	unsigned int tmp[NUM_ECC_WORDS];
+	int carry;
+
+	/* t */
+	uECC_vli_set(result, product);
+
+	/* s1 */
+	tmp[0] = tmp[1] = tmp[2] = 0;
+	tmp[3] = product[11];
+	tmp[4] = product[12];
+	tmp[5] = product[13];
+	tmp[6] = product[14];
+	tmp[7] = product[15];
+	carry = uECC_vli_add(tmp, tmp, tmp);
+	carry += uECC_vli_add(result, result, tmp);
+
+	/* s2 */
+	tmp[3] = product[12];
+	tmp[4] = product[13];
+	tmp[5] = product[14];
+	tmp[6] = product[15];
+	tmp[7] = 0;
+	carry += uECC_vli_add(tmp, tmp, tmp);
+	carry += uECC_vli_add(result, result, tmp);
+
+	/* s3 */
+	tmp[0] = product[8];
+	tmp[1] = product[9];
+	tmp[2] = product[10];
+	tmp[3] = tmp[4] = tmp[5] = 0;
+	tmp[6] = product[14];
+	tmp[7] = product[15];
+  	carry += uECC_vli_add(result, result, tmp);
+
+	/* s4 */
+	tmp[0] = product[9];
+	tmp[1] = product[10];
+	tmp[2] = product[11];
+	tmp[3] = product[13];
+	tmp[4] = product[14];
+	tmp[5] = product[15];
+	tmp[6] = product[13];
+	tmp[7] = product[8];
+	carry += uECC_vli_add(result, result, tmp);
+
+	/* d1 */
+	tmp[0] = product[11];
+	tmp[1] = product[12];
+	tmp[2] = product[13];
+	tmp[3] = tmp[4] = tmp[5] = 0;
+	tmp[6] = product[8];
+	tmp[7] = product[10];
+	carry -= uECC_vli_sub(result, result, tmp);
+
+	/* d2 */
+	tmp[0] = product[12];
+	tmp[1] = product[13];
+	tmp[2] = product[14];
+	tmp[3] = product[15];
+	tmp[4] = tmp[5] = 0;
+	tmp[6] = product[9];
+	tmp[7] = product[11];
+	carry -= uECC_vli_sub(result, result, tmp);
+
+	/* d3 */
+	tmp[0] = product[13];
+	tmp[1] = product[14];
+	tmp[2] = product[15];
+	tmp[3] = product[8];
+	tmp[4] = product[9];
+	tmp[5] = product[10];
+	tmp[6] = 0;
+	tmp[7] = product[12];
+	carry -= uECC_vli_sub(result, result, tmp);
+
+	/* d4 */
+	tmp[0] = product[14];
+	tmp[1] = product[15];
+	tmp[2] = 0;
+	tmp[3] = product[9];
+	tmp[4] = product[10];
+	tmp[5] = product[11];
+	tmp[6] = 0;
+	tmp[7] = product[13];
+	carry -= uECC_vli_sub(result, result, tmp);
+
+	if (carry < 0) {
+		do {
+			carry += uECC_vli_add(result, result, curve_p);
+		}
+		while (carry < 0);
+	} else  {
+		while (carry ||
+			   uECC_vli_cmp_unsafe(curve_p, result) != 1) {
+			carry -= uECC_vli_sub(result, result, curve_p);
+		}
+	}
+}
+
+uECC_word_t EccPoint_isZero(const uECC_word_t *point)
+{
+	return uECC_vli_isZero(point);
+}
+
+void apply_z(uECC_word_t * X1, uECC_word_t * Y1, const uECC_word_t * const Z)
+{
+	uECC_word_t t1[NUM_ECC_WORDS];
+
+	uECC_vli_modMult_fast(t1, Z, Z);	/* z^2 */
+	uECC_vli_modMult_fast(X1, X1, t1); /* x1 * z^2 */
+	uECC_vli_modMult_fast(t1, t1, Z);  /* z^3 */
+	uECC_vli_modMult_fast(Y1, Y1, t1); /* y1 * z^3 */
+}
+
+/* P = (x1, y1) => 2P, (x2, y2) => P' */
+static void XYcZ_initial_double(uECC_word_t * X1, uECC_word_t * Y1,
+				uECC_word_t * X2, uECC_word_t * Y2,
+				const uECC_word_t * const initial_Z)
+{
+	uECC_word_t z[NUM_ECC_WORDS];
+	if (initial_Z) {
+		uECC_vli_set(z, initial_Z);
+	} else {
+		uECC_vli_clear(z);
+		z[0] = 1;
+	}
+
+	uECC_vli_set(X2, X1);
+	uECC_vli_set(Y2, Y1);
+
+	apply_z(X1, Y1, z);
+	double_jacobian_default(X1, Y1, z);
+	apply_z(X2, Y2, z);
+}
+
+static void XYcZ_add_rnd(uECC_word_t * X1, uECC_word_t * Y1,
+			 uECC_word_t * X2, uECC_word_t * Y2,
+			 ecc_wait_state_t *s)
+{
+	/* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
+	uECC_word_t t5[NUM_ECC_WORDS];
+
+	uECC_vli_modSub(t5, X2, X1, curve_p); /* t5 = x2 - x1 */
+	uECC_vli_modMult_rnd(t5, t5, t5, s); /* t5 = (x2 - x1)^2 = A */
+	uECC_vli_modMult_rnd(X1, X1, t5, s); /* t1 = x1*A = B */
+	uECC_vli_modMult_rnd(X2, X2, t5, s); /* t3 = x2*A = C */
+	uECC_vli_modSub(Y2, Y2, Y1, curve_p); /* t4 = y2 - y1 */
+	uECC_vli_modMult_rnd(t5, Y2, Y2, s); /* t5 = (y2 - y1)^2 = D */
+
+	uECC_vli_modSub(t5, t5, X1, curve_p); /* t5 = D - B */
+	uECC_vli_modSub(t5, t5, X2, curve_p); /* t5 = D - B - C = x3 */
+	uECC_vli_modSub(X2, X2, X1, curve_p); /* t3 = C - B */
+	uECC_vli_modMult_rnd(Y1, Y1, X2, s); /* t2 = y1*(C - B) */
+	uECC_vli_modSub(X2, X1, t5, curve_p); /* t3 = B - x3 */
+	uECC_vli_modMult_rnd(Y2, Y2, X2, s); /* t4 = (y2 - y1)*(B - x3) */
+	uECC_vli_modSub(Y2, Y2, Y1, curve_p); /* t4 = y3 */
+
+	uECC_vli_set(X2, t5);
+}
+
+void XYcZ_add(uECC_word_t * X1, uECC_word_t * Y1,
+		  uECC_word_t * X2, uECC_word_t * Y2)
+{
+	XYcZ_add_rnd(X1, Y1, X2, Y2, NULL);
+}
+
+/* Input P = (x1, y1, Z), Q = (x2, y2, Z)
+   Output P + Q = (x3, y3, Z3), P - Q = (x3', y3', Z3)
+   or P => P - Q, Q => P + Q
+ */
+static void XYcZ_addC_rnd(uECC_word_t * X1, uECC_word_t * Y1,
+			  uECC_word_t * X2, uECC_word_t * Y2,
+			  ecc_wait_state_t *s)
+{
+	/* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
+	uECC_word_t t5[NUM_ECC_WORDS];
+	uECC_word_t t6[NUM_ECC_WORDS];
+	uECC_word_t t7[NUM_ECC_WORDS];
+
+	uECC_vli_modSub(t5, X2, X1, curve_p); /* t5 = x2 - x1 */
+	uECC_vli_modMult_rnd(t5, t5, t5, s); /* t5 = (x2 - x1)^2 = A */
+	uECC_vli_modMult_rnd(X1, X1, t5, s); /* t1 = x1*A = B */
+	uECC_vli_modMult_rnd(X2, X2, t5, s); /* t3 = x2*A = C */
+	uECC_vli_modAdd(t5, Y2, Y1, curve_p); /* t5 = y2 + y1 */
+	uECC_vli_modSub(Y2, Y2, Y1, curve_p); /* t4 = y2 - y1 */
+
+	uECC_vli_modSub(t6, X2, X1, curve_p); /* t6 = C - B */
+	uECC_vli_modMult_rnd(Y1, Y1, t6, s); /* t2 = y1 * (C - B) = E */
+	uECC_vli_modAdd(t6, X1, X2, curve_p); /* t6 = B + C */
+	uECC_vli_modMult_rnd(X2, Y2, Y2, s); /* t3 = (y2 - y1)^2 = D */
+	uECC_vli_modSub(X2, X2, t6, curve_p); /* t3 = D - (B + C) = x3 */
+
+	uECC_vli_modSub(t7, X1, X2, curve_p); /* t7 = B - x3 */
+	uECC_vli_modMult_rnd(Y2, Y2, t7, s); /* t4 = (y2 - y1)*(B - x3) */
+	/* t4 = (y2 - y1)*(B - x3) - E = y3: */
+	uECC_vli_modSub(Y2, Y2, Y1, curve_p);
+
+	uECC_vli_modMult_rnd(t7, t5, t5, s); /* t7 = (y2 + y1)^2 = F */
+	uECC_vli_modSub(t7, t7, t6, curve_p); /* t7 = F - (B + C) = x3' */
+	uECC_vli_modSub(t6, t7, X1, curve_p); /* t6 = x3' - B */
+	uECC_vli_modMult_rnd(t6, t6, t5, s); /* t6 = (y2+y1)*(x3' - B) */
+	/* t2 = (y2+y1)*(x3' - B) - E = y3': */
+	uECC_vli_modSub(Y1, t6, Y1, curve_p);
+
+	uECC_vli_set(X1, t7);
+}
+
+static void EccPoint_mult(uECC_word_t * result, const uECC_word_t * point,
+		   const uECC_word_t * scalar,
+		   const uECC_word_t * initial_Z)
+{
+	/* R0 and R1 */
+	uECC_word_t Rx[2][NUM_ECC_WORDS];
+	uECC_word_t Ry[2][NUM_ECC_WORDS];
+	uECC_word_t z[NUM_ECC_WORDS];
+	bitcount_t i;
+	uECC_word_t nb;
+	const wordcount_t num_words = NUM_ECC_WORDS;
+	const bitcount_t num_bits = NUM_ECC_BITS + 1; /* from regularize_k */
+	ecc_wait_state_t wait_state;
+	ecc_wait_state_t * const ws = g_rng_function ? &wait_state : NULL;
+
+	uECC_vli_set(Rx[1], point);
+  	uECC_vli_set(Ry[1], point + num_words);
+
+	XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z);
+
+	for (i = num_bits - 2; i > 0; --i) {
+		ecc_wait_state_reset(ws);
+		nb = !uECC_vli_testBit(scalar, i);
+		XYcZ_addC_rnd(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], ws);
+		XYcZ_add_rnd(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], ws);
+	}
+
+	ecc_wait_state_reset(ws);
+	nb = !uECC_vli_testBit(scalar, 0);
+	XYcZ_addC_rnd(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], ws);
+
+	/* Find final 1/Z value. */
+	uECC_vli_modSub(z, Rx[1], Rx[0], curve_p); /* X1 - X0 */
+	uECC_vli_modMult_fast(z, z, Ry[1 - nb]); /* Yb * (X1 - X0) */
+	uECC_vli_modMult_fast(z, z, point); /* xP * Yb * (X1 - X0) */
+	uECC_vli_modInv(z, z, curve_p); /* 1 / (xP * Yb * (X1 - X0))*/
+	/* yP / (xP * Yb * (X1 - X0)) */
+	uECC_vli_modMult_fast(z, z, point + num_words);
+	/* Xb * yP / (xP * Yb * (X1 - X0)) */
+	uECC_vli_modMult_fast(z, z, Rx[1 - nb]);
+	/* End 1/Z calculation */
+
+	XYcZ_add_rnd(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], ws);
+	apply_z(Rx[0], Ry[0], z);
+
+	uECC_vli_set(result, Rx[0]);
+	uECC_vli_set(result + num_words, Ry[0]);
+}
+
+static uECC_word_t regularize_k(const uECC_word_t * const k, uECC_word_t *k0,
+			 uECC_word_t *k1)
+{
+	wordcount_t num_n_words = NUM_ECC_WORDS;	
+	bitcount_t num_n_bits = NUM_ECC_BITS;
+
+	/* With our constant NUM_ECC_BITS and NUM_ECC_WORDS the
+	 * check (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) always would have "false" result (256 < 256),
+	 * therefore Coverity warning may be detected. Removing of this line without changing the entire check will cause to 
+	 * array overrun.
+	 * The entire check is not changed on purpose  to be aligned with original tinycrypt
+	 * implementation and to allow upstreaming to other curves if required.
+	 * Coverity specific annotation may be added to silence warning if exists.    
+	*/
+	uECC_word_t carry = uECC_vli_add(k0, k, curve_n) ||
+			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
+			     uECC_vli_testBit(k0, num_n_bits));
+
+	uECC_vli_add(k1, k0, curve_n);
+
+	return carry;
+}
+
+int EccPoint_mult_safer(uECC_word_t * result, const uECC_word_t * point,
+			const uECC_word_t * scalar)
+{
+	uECC_word_t tmp[NUM_ECC_WORDS];
+	uECC_word_t s[NUM_ECC_WORDS];
+	uECC_word_t *k2[2] = {tmp, s};
+	wordcount_t num_words = NUM_ECC_WORDS;
+	uECC_word_t carry;
+	uECC_word_t *initial_Z = 0;
+	int r = UECC_FAULT_DETECTED;
+	volatile int problem;
+
+	/* Protect against faults modifying curve paremeters in flash */
+	problem = -1;
+	problem = uECC_check_curve_integrity();
+	if (problem != 0) {
+		return UECC_FAULT_DETECTED;
+	}
+	mbedtls_platform_random_delay();
+	if (problem != 0) {
+		return UECC_FAULT_DETECTED;
+	}
+
+	/* Protects against invalid curve attacks */
+	problem = -1;
+	problem = uECC_valid_point(point);
+	if (problem != 0) {
+		/* invalid input, can happen without fault */
+		return UECC_FAILURE;
+	}
+	mbedtls_platform_random_delay();
+	if (problem != 0) {
+		/* failure on second check means fault, though */
+		return UECC_FAULT_DETECTED;
+	}
+
+	/* Regularize the bitcount for the private key so that attackers cannot use a
+	 * side channel attack to learn the number of leading zeros. */
+	carry = regularize_k(scalar, tmp, s);
+
+	/* If an RNG function was specified, get a random initial Z value to
+		 * protect against side-channel attacks such as Template SPA */
+	if (g_rng_function) {
+		if (uECC_generate_random_int(k2[carry], curve_p, num_words) != UECC_SUCCESS) {
+			r = UECC_FAILURE;
+			goto clear_and_out;
+		}
+		initial_Z = k2[carry];
+	}
+
+	EccPoint_mult(result, point, k2[!carry], initial_Z);
+
+	/* Protect against fault injections that would make the resulting
+	 * point not lie on the intended curve */
+	problem = -1;
+	problem = uECC_valid_point(result);
+	if (problem != 0) {
+		r = UECC_FAULT_DETECTED;
+		goto clear_and_out;
+	}
+	mbedtls_platform_random_delay();
+	if (problem != 0) {
+		r = UECC_FAULT_DETECTED;
+		goto clear_and_out;
+	}
+
+	/* Protect against faults modifying curve paremeters in flash */
+	problem = -1;
+	problem = uECC_check_curve_integrity();
+	if (problem != 0) {
+		r = UECC_FAULT_DETECTED;
+		goto clear_and_out;
+	}
+	mbedtls_platform_random_delay();
+	if (problem != 0) {
+		r = UECC_FAULT_DETECTED;
+		goto clear_and_out;
+	}
+
+	r = UECC_SUCCESS;
+
+clear_and_out:
+	/* erasing temporary buffer used to store secret: */
+	mbedtls_platform_zeroize(k2, sizeof(k2));
+	mbedtls_platform_zeroize(tmp, sizeof(tmp));
+	mbedtls_platform_zeroize(s, sizeof(s));
+
+	return r;
+}
+
+uECC_word_t EccPoint_compute_public_key(uECC_word_t *result,
+					uECC_word_t *private_key)
+{
+	return EccPoint_mult_safer(result, curve_G, private_key);
+}
+
+/* Converts an integer in uECC native format to big-endian bytes. */
+void uECC_vli_nativeToBytes(uint8_t *bytes, int num_bytes,
+				const unsigned int *native)
+{
+	wordcount_t i;
+	for (i = 0; i < num_bytes; ++i) {
+		unsigned b = num_bytes - 1 - i;
+		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
+	}
+}
+
+/* Converts big-endian bytes to an integer in uECC native format. */
+void uECC_vli_bytesToNative(unsigned int *native, const uint8_t *bytes,
+				int num_bytes)
+{
+	wordcount_t i;
+	uECC_vli_clear(native);
+	for (i = 0; i < num_bytes; ++i) {
+		unsigned b = num_bytes - 1 - i;
+		native[b / uECC_WORD_SIZE] |=
+			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
+  	}
+}
+
+int uECC_generate_random_int(uECC_word_t *random, const uECC_word_t *top,
+				 wordcount_t num_words)
+{
+	uECC_word_t mask = (uECC_word_t)-1;
+	uECC_word_t tries;
+	bitcount_t num_bits = uECC_vli_numBits(top);
+
+	if (!g_rng_function) {
+		return UECC_FAILURE;
+	}
+
+	for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
+		if (g_rng_function((uint8_t *)random, num_words * uECC_WORD_SIZE) != num_words * uECC_WORD_SIZE) {
+	  			return UECC_FAILURE;
+			}
+		random[num_words - 1] &=
+				mask >> ((bitcount_t)(num_words * uECC_WORD_SIZE * 8 - num_bits));
+		if (!uECC_vli_isZero(random) &&
+			uECC_vli_cmp(top, random) == 1) {
+			return UECC_SUCCESS;
+		}
+	}
+	return UECC_FAILURE;
+}
+
+
+int uECC_valid_point(const uECC_word_t *point)
+{
+	uECC_word_t tmp1[NUM_ECC_WORDS];
+	uECC_word_t tmp2[NUM_ECC_WORDS];
+	wordcount_t num_words = NUM_ECC_WORDS;
+	volatile uECC_word_t diff = 0xffffffff;
+
+	/* The point at infinity is invalid. */
+	if (EccPoint_isZero(point)) {
+		return -1;
+	}
+
+	/* x and y must be smaller than p. */
+	if (uECC_vli_cmp_unsafe(curve_p, point) != 1 ||
+		uECC_vli_cmp_unsafe(curve_p, point + num_words) != 1) {
+		return -2;
+	}
+
+	uECC_vli_modMult_fast(tmp1, point + num_words, point + num_words);
+	x_side_default(tmp2, point); /* tmp2 = x^3 + ax + b */
+
+	/* Make sure that y^2 == x^3 + ax + b */
+	diff = uECC_vli_equal(tmp1, tmp2);
+	if (diff == 0) {
+		mbedtls_platform_random_delay();
+		if (diff == 0) {
+			return 0;
+		}
+	}
+
+	return -3;
+}
+
+int uECC_valid_public_key(const uint8_t *public_key)
+{
+
+	uECC_word_t _public[NUM_ECC_WORDS * 2];
+
+	uECC_vli_bytesToNative(_public, public_key, NUM_ECC_BYTES);
+	uECC_vli_bytesToNative(
+	_public + NUM_ECC_WORDS,
+	public_key + NUM_ECC_BYTES,
+	NUM_ECC_BYTES);
+
+	if (memcmp(_public, curve_G, NUM_ECC_WORDS * 2) == 0) {
+		return -4;
+	}
+
+	return uECC_valid_point(_public);
+}
+
+int uECC_compute_public_key(const uint8_t *private_key, uint8_t *public_key)
+{
+	int ret = UECC_FAULT_DETECTED;
+	uECC_word_t _private[NUM_ECC_WORDS];
+	uECC_word_t _public[NUM_ECC_WORDS * 2];
+
+	uECC_vli_bytesToNative(
+	_private,
+	private_key,
+	BITS_TO_BYTES(NUM_ECC_BITS));
+
+	/* Make sure the private key is in the range [1, n-1]. */
+	if (uECC_vli_isZero(_private)) {
+		return UECC_FAILURE;
+	}
+
+	if (uECC_vli_cmp(curve_n, _private) != 1) {
+		return UECC_FAILURE;
+	}
+
+	/* Compute public key. */
+	ret = EccPoint_compute_public_key(_public, _private);
+	if (ret != UECC_SUCCESS) {
+		return ret;
+	}
+
+	uECC_vli_nativeToBytes(public_key, NUM_ECC_BYTES, _public);
+	uECC_vli_nativeToBytes(
+	public_key +
+	NUM_ECC_BYTES, NUM_ECC_BYTES, _public + NUM_ECC_WORDS);
+
+	return ret;
+}
+#endif /* MBEDTLS_USE_TINYCRYPT */
diff --git a/tinycrypt/ecc_dh.c b/tinycrypt/ecc_dh.c
new file mode 100755
index 000000000..b6b1898d3
--- /dev/null
+++ b/tinycrypt/ecc_dh.c
@@ -0,0 +1,199 @@
+/* ec_dh.c - TinyCrypt implementation of EC-DH */
+
+/*
+ *  Copyright (c) 2019, Arm Limited (or its affiliates), All Rights Reserved.
+ *  SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*
+ * Copyright (c) 2014, Kenneth MacKay
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *  * Redistributions of source code must retain the above copyright notice,
+ *	this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *	this list of conditions and the following disclaimer in the documentation
+ *	and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *  Copyright (C) 2017 by Intel Corporation, All Rights Reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *	- Redistributions of source code must retain the above copyright notice,
+ *	 this list of conditions and the following disclaimer.
+ *
+ *	- Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ *
+ *	- Neither the name of Intel Corporation nor the names of its contributors
+ *	may be used to endorse or promote products derived from this software
+ *	without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#if !defined(MBEDTLS_CONFIG_FILE)
+#include "mbedtls/config.h"
+#else
+#include MBEDTLS_CONFIG_FILE
+#endif
+
+#if defined(MBEDTLS_USE_TINYCRYPT)
+#include <tinycrypt/ecc.h>
+#include <tinycrypt/ecc_dh.h>
+#include <string.h>
+#include "mbedtls/platform_util.h"
+
+int uECC_make_key_with_d(uint8_t *public_key, uint8_t *private_key,
+			 unsigned int *d)
+{
+	int ret = UECC_FAULT_DETECTED;
+	uECC_word_t _private[NUM_ECC_WORDS];
+	uECC_word_t _public[NUM_ECC_WORDS * 2];
+
+	/* This function is designed for test purposes-only (such as validating NIST
+	 * test vectors) as it uses a provided value for d instead of generating
+	 * it uniformly at random. */
+	if( mbedtls_platform_memcpy (_private, d, NUM_ECC_BYTES) != _private )
+	{
+		goto exit;
+	}
+
+	/* Computing public-key from private: */
+	ret = EccPoint_compute_public_key(_public, _private);
+	if (ret != UECC_SUCCESS) {
+		goto exit;
+	}
+
+	/* Converting buffers to correct bit order: */
+	uECC_vli_nativeToBytes(private_key,
+				   BITS_TO_BYTES(NUM_ECC_BITS),
+				   _private);
+	uECC_vli_nativeToBytes(public_key,
+				   NUM_ECC_BYTES,
+				   _public);
+	uECC_vli_nativeToBytes(public_key + NUM_ECC_BYTES,
+				   NUM_ECC_BYTES,
+				   _public + NUM_ECC_WORDS);
+
+exit:
+	/* erasing temporary buffer used to store secret: */
+	mbedtls_platform_memset(_private, 0, NUM_ECC_BYTES);
+
+	return ret;
+}
+
+int uECC_make_key(uint8_t *public_key, uint8_t *private_key)
+{
+	int ret = UECC_FAULT_DETECTED;
+	uECC_word_t _random[NUM_ECC_WORDS * 2];
+	uECC_word_t _private[NUM_ECC_WORDS];
+	uECC_word_t _public[NUM_ECC_WORDS * 2];
+	uECC_word_t tries;
+	volatile uint8_t *public_key_dup = public_key;
+	volatile uint8_t *private_key_dup = private_key;
+
+	for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
+		/* Generating _private uniformly at random: */
+		uECC_RNG_Function rng_function = uECC_get_rng();
+		if (!rng_function ||
+			rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE) != 2 * NUM_ECC_WORDS*uECC_WORD_SIZE) {
+				return UECC_FAILURE;
+		}
+
+		/* computing modular reduction of _random (see FIPS 186.4 B.4.1): */
+		uECC_vli_mmod(_private, _random, curve_n);
+
+		/* Computing public-key from private: */
+		ret = EccPoint_compute_public_key(_public, _private);
+		/* don't try again if a fault was detected */
+		if (ret == UECC_FAULT_DETECTED) {
+			return ret;
+		}
+		if (ret == UECC_SUCCESS) {
+
+			/* Converting buffers to correct bit order: */
+			uECC_vli_nativeToBytes(private_key,
+						   BITS_TO_BYTES(NUM_ECC_BITS),
+						   _private);
+			uECC_vli_nativeToBytes(public_key,
+						   NUM_ECC_BYTES,
+						   _public);
+			uECC_vli_nativeToBytes(public_key + NUM_ECC_BYTES,
+ 						   NUM_ECC_BYTES,
+						   _public + NUM_ECC_WORDS);
+
+			/* erasing temporary buffer that stored secret: */
+			mbedtls_platform_memset(_private, 0, NUM_ECC_BYTES);
+
+			if (private_key == private_key_dup && public_key == public_key_dup) {
+				return UECC_SUCCESS;
+			}
+			/* Erase key in case of FI */
+			mbedtls_platform_memset(public_key, 0, 2*NUM_ECC_BYTES);
+			return UECC_FAULT_DETECTED;
+		}
+  	}
+	return UECC_FAILURE;
+}
+
+int uECC_shared_secret(const uint8_t *public_key, const uint8_t *private_key,
+			   uint8_t *secret)
+{
+
+	uECC_word_t _public[NUM_ECC_WORDS * 2];
+	uECC_word_t _private[NUM_ECC_WORDS];
+	wordcount_t num_words = NUM_ECC_WORDS;
+	wordcount_t num_bytes = NUM_ECC_BYTES;
+	int r = UECC_FAULT_DETECTED;
+
+	/* Converting buffers to correct bit order: */
+	uECC_vli_bytesToNative(_private,
+	  				   private_key,
+				   BITS_TO_BYTES(NUM_ECC_BITS));
+	uECC_vli_bytesToNative(_public,
+	  				   public_key,
+				   num_bytes);
+	uECC_vli_bytesToNative(_public + num_words,
+				   public_key + num_bytes,
+				   num_bytes);
+
+	r = EccPoint_mult_safer(_public, _public, _private);
+	uECC_vli_nativeToBytes(secret, num_bytes, _public);
+
+	/* erasing temporary buffer used to store secret: */
+	if (_private == mbedtls_platform_zeroize(_private, sizeof(_private))) {
+		return r;
+	}
+
+	return UECC_FAULT_DETECTED;
+}
+#endif /* MBEDTLS_USE_TINYCRYPT */
diff --git a/tinycrypt/ecc_dsa.c b/tinycrypt/ecc_dsa.c
new file mode 100755
index 000000000..fe3952c2d
--- /dev/null
+++ b/tinycrypt/ecc_dsa.c
@@ -0,0 +1,318 @@
+/* ec_dsa.c - TinyCrypt implementation of EC-DSA */
+
+/*
+ *  Copyright (c) 2019, Arm Limited (or its affiliates), All Rights Reserved.
+ *  SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/* Copyright (c) 2014, Kenneth MacKay
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *  * Redistributions of source code must retain the above copyright notice,
+ *	this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *	this list of conditions and the following disclaimer in the documentation
+ *	and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.*/
+
+/*
+ *  Copyright (C) 2017 by Intel Corporation, All Rights Reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *
+ *	- Redistributions of source code must retain the above copyright notice,
+ *	 this list of conditions and the following disclaimer.
+ *
+ *	- Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ *
+ *	- Neither the name of Intel Corporation nor the names of its contributors
+ *	may be used to endorse or promote products derived from this software
+ *	without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#if !defined(MBEDTLS_CONFIG_FILE)
+#include "mbedtls/config.h"
+#else
+#include MBEDTLS_CONFIG_FILE
+#endif
+
+#if defined(MBEDTLS_USE_TINYCRYPT)
+#include <tinycrypt/ecc.h>
+#include <tinycrypt/ecc_dsa.h>
+#include "mbedtls/platform_util.h"
+
+static void bits2int(uECC_word_t *native, const uint8_t *bits,
+			 unsigned bits_size)
+{
+	unsigned num_n_bytes = BITS_TO_BYTES(NUM_ECC_BITS);
+
+	if (bits_size > num_n_bytes) {
+		bits_size = num_n_bytes;
+	}
+
+	uECC_vli_clear(native);
+	uECC_vli_bytesToNative(native, bits, bits_size);
+}
+
+int uECC_sign_with_k(const uint8_t *private_key, const uint8_t *message_hash,
+			 unsigned hash_size, uECC_word_t *k, uint8_t *signature)
+{
+
+	uECC_word_t tmp[NUM_ECC_WORDS];
+	uECC_word_t s[NUM_ECC_WORDS];
+	uECC_word_t p[NUM_ECC_WORDS * 2];
+	wordcount_t num_n_words = BITS_TO_WORDS(NUM_ECC_BITS);
+	int r = UECC_FAILURE;
+
+
+	/* Make sure 0 < k < curve_n */
+  	if (uECC_vli_isZero(k) ||
+		uECC_vli_cmp(curve_n, k) != 1) {
+		return UECC_FAILURE;
+	}
+
+	r = EccPoint_mult_safer(p, curve_G, k);
+		if (r != UECC_SUCCESS) {
+		return r;
+	}
+
+	/* If an RNG function was specified, get a random number
+	to prevent side channel analysis of k. */
+	if (!uECC_get_rng()) {
+		uECC_vli_clear(tmp);
+		tmp[0] = 1;
+	}
+	else if (uECC_generate_random_int(tmp, curve_n, num_n_words) != UECC_SUCCESS) {
+		return UECC_FAILURE;
+	}
+
+	/* Prevent side channel analysis of uECC_vli_modInv() to determine
+	bits of k / the private key by premultiplying by a random number */
+	uECC_vli_modMult(k, k, tmp, curve_n); /* k' = rand * k */
+	uECC_vli_modInv(k, k, curve_n);	   /* k = 1 / k' */
+	uECC_vli_modMult(k, k, tmp, curve_n); /* k = 1 / k */
+
+	uECC_vli_nativeToBytes(signature, NUM_ECC_BYTES, p); /* store r */
+
+	/* tmp = d: */
+	uECC_vli_bytesToNative(tmp, private_key, BITS_TO_BYTES(NUM_ECC_BITS));
+
+	s[num_n_words - 1] = 0;
+	uECC_vli_set(s, p);
+	uECC_vli_modMult(s, tmp, s, curve_n); /* s = r*d */
+
+	bits2int(tmp, message_hash, hash_size);
+	uECC_vli_modAdd(s, tmp, s, curve_n); /* s = e + r*d */
+	uECC_vli_modMult(s, s, k, curve_n);  /* s = (e + r*d) / k */
+	if (uECC_vli_numBits(s) > (bitcount_t)NUM_ECC_BYTES * 8) {
+		return UECC_FAILURE;
+	}
+
+	uECC_vli_nativeToBytes(signature + NUM_ECC_BYTES, NUM_ECC_BYTES, s);
+	return r;
+}
+
+int uECC_sign(const uint8_t *private_key, const uint8_t *message_hash,
+		  unsigned hash_size, uint8_t *signature)
+{
+	int r;
+	uECC_word_t _random[2*NUM_ECC_WORDS];
+	uECC_word_t k[NUM_ECC_WORDS];
+	uECC_word_t tries;
+	volatile const uint8_t *private_key_dup = private_key;
+	volatile const uint8_t *message_hash_dup = message_hash;
+	volatile unsigned hash_size_dup = hash_size;
+	volatile uint8_t *signature_dup = signature;
+
+	for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
+		/* Generating _random uniformly at random: */
+		uECC_RNG_Function rng_function = uECC_get_rng();
+		if (!rng_function ||
+			rng_function((uint8_t *)_random, 2*NUM_ECC_WORDS*uECC_WORD_SIZE) != 2*NUM_ECC_WORDS*uECC_WORD_SIZE) {
+			return UECC_FAILURE;
+		}
+
+		// computing k as modular reduction of _random (see FIPS 186.4 B.5.1):
+		uECC_vli_mmod(k, _random, curve_n);
+
+		r = uECC_sign_with_k(private_key, message_hash, hash_size, k, signature);
+		/* don't keep trying if a fault was detected */
+		if (r == UECC_FAULT_DETECTED) {
+		    mbedtls_platform_memset(signature, 0, 2*NUM_ECC_BYTES);
+			return r;
+		}
+		if (r == UECC_SUCCESS) {
+			if (private_key_dup != private_key || message_hash_dup != message_hash ||
+				hash_size_dup != hash_size || signature_dup != signature) {
+			    mbedtls_platform_memset(signature, 0, 2*NUM_ECC_BYTES);
+				return UECC_FAULT_DETECTED;
+			}
+			return UECC_SUCCESS;
+		}
+		/* else keep trying */
+	}
+	return UECC_FAILURE;
+}
+
+static bitcount_t smax(bitcount_t a, bitcount_t b)
+{
+	return (a > b ? a : b);
+}
+
+int uECC_verify(const uint8_t *public_key, const uint8_t *message_hash,
+		unsigned hash_size, const uint8_t *signature)
+{
+
+	uECC_word_t u1[NUM_ECC_WORDS], u2[NUM_ECC_WORDS];
+	uECC_word_t z[NUM_ECC_WORDS];
+	uECC_word_t sum[NUM_ECC_WORDS * 2];
+	uECC_word_t rx[NUM_ECC_WORDS];
+	uECC_word_t ry[NUM_ECC_WORDS];
+	uECC_word_t tx[NUM_ECC_WORDS];
+	uECC_word_t ty[NUM_ECC_WORDS];
+	uECC_word_t tz[NUM_ECC_WORDS];
+	const uECC_word_t *points[4];
+	const uECC_word_t *point;
+	bitcount_t num_bits;
+	bitcount_t i;
+	bitcount_t flow_control;
+	volatile uECC_word_t diff;
+
+	uECC_word_t _public[NUM_ECC_WORDS * 2];
+	uECC_word_t r[NUM_ECC_WORDS], s[NUM_ECC_WORDS];
+	wordcount_t num_words = NUM_ECC_WORDS;
+	wordcount_t num_n_words = BITS_TO_WORDS(NUM_ECC_BITS);
+
+	rx[num_n_words - 1] = 0;
+	r[num_n_words - 1] = 0;
+	s[num_n_words - 1] = 0;
+	flow_control = 1;
+
+	uECC_vli_bytesToNative(_public, public_key, NUM_ECC_BYTES);
+	uECC_vli_bytesToNative(_public + num_words, public_key + NUM_ECC_BYTES,
+				   NUM_ECC_BYTES);
+	uECC_vli_bytesToNative(r, signature, NUM_ECC_BYTES);
+	uECC_vli_bytesToNative(s, signature + NUM_ECC_BYTES, NUM_ECC_BYTES);
+
+	/* r, s must not be 0. */
+	if (uECC_vli_isZero(r) || uECC_vli_isZero(s)) {
+		return UECC_FAILURE;
+	}
+
+	/* r, s must be < n. */
+	if (uECC_vli_cmp_unsafe(curve_n, r) != 1 ||
+		uECC_vli_cmp_unsafe(curve_n, s) != 1) {
+		return UECC_FAILURE;
+	}
+
+	flow_control++;
+
+	/* Calculate u1 and u2. */
+	uECC_vli_modInv(z, s, curve_n); /* z = 1/s */
+	u1[num_n_words - 1] = 0;
+	bits2int(u1, message_hash, hash_size);
+	uECC_vli_modMult(u1, u1, z, curve_n); /* u1 = e/s */
+	uECC_vli_modMult(u2, r, z, curve_n); /* u2 = r/s */
+
+	/* Calculate sum = G + Q. */
+	uECC_vli_set(sum, _public);
+	uECC_vli_set(sum + num_words, _public + num_words);
+	uECC_vli_set(tx, curve_G);
+	uECC_vli_set(ty, curve_G + num_words);
+	uECC_vli_modSub(z, sum, tx, curve_p); /* z = x2 - x1 */
+	XYcZ_add(tx, ty, sum, sum + num_words);
+	uECC_vli_modInv(z, z, curve_p); /* z = 1/z */
+	apply_z(sum, sum + num_words, z);
+
+	flow_control++;
+
+	/* Use Shamir's trick to calculate u1*G + u2*Q */
+	points[0] = 0;
+	points[1] = curve_G;
+	points[2] = _public;
+	points[3] = sum;
+	num_bits = smax(uECC_vli_numBits(u1),
+	uECC_vli_numBits(u2));
+
+	point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
+					   ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];
+	uECC_vli_set(rx, point);
+	uECC_vli_set(ry, point + num_words);
+	uECC_vli_clear(z);
+	z[0] = 1;
+	flow_control++;
+
+	for (i = num_bits - 2; i >= 0; --i) {
+		uECC_word_t index;
+		double_jacobian_default(rx, ry, z);
+
+		index = (!!uECC_vli_testBit(u1, i)) | ((!!uECC_vli_testBit(u2, i)) << 1);
+		point = points[index];
+		if (point) {
+			uECC_vli_set(tx, point);
+			uECC_vli_set(ty, point + num_words);
+			apply_z(tx, ty, z);
+			uECC_vli_modSub(tz, rx, tx, curve_p); /* Z = x2 - x1 */
+			XYcZ_add(tx, ty, rx, ry);
+			uECC_vli_modMult_fast(z, z, tz);
+		}
+		flow_control++;
+  	}
+
+	uECC_vli_modInv(z, z, curve_p); /* Z = 1/Z */
+	apply_z(rx, ry, z);
+	flow_control++;
+
+	/* v = x1 (mod n) */
+	if (uECC_vli_cmp_unsafe(curve_n, rx) != 1) {
+		uECC_vli_sub(rx, rx, curve_n);
+	}
+
+	/* Accept only if v == r. */
+	diff = uECC_vli_equal(rx, r);
+	if (diff == 0) {
+		flow_control++;
+		mbedtls_platform_random_delay();
+
+		/* Re-check the condition and test if the control flow is as expected.
+		 * 1 (base value) + num_bits - 1 (from the loop) + 5 incrementations.
+		 */
+		if (diff == 0 && flow_control == (num_bits + 5)) {
+			return UECC_SUCCESS;
+		}
+		else {
+			return UECC_FAULT_DETECTED;
+		}
+	}
+
+	return UECC_FAILURE;
+}
+#endif /* MBEDTLS_USE_TINYCRYPT */
-- 
2.25.1

